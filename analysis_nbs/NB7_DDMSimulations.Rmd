---
title: "Experience vs. description based decision-making project: Adding arbitration to behavioral modeling"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

Set up environment and load in data

```{r include=FALSE}
library(tidyverse)
library(gridExtra)
library(brms)
library(here)
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# theme_set(theme_bw())
theme_set(theme_classic())
sem <- function(x) {sd(x, na.rm=T) / sqrt(length(x))}
helpers_path = here('helpers/')
```


```{r}
source(paste0(helpers_path,'fit_twoValSystemsWithRL_hierarchical.R'))
source(paste0(helpers_path,'add_inferred_pars.R'))
clean_beh_data = add_inferred_pars(clean_beh_data, par_ests, model_name="original")
```


Expanded DDM that can take task specific arguments as input

```{r}
sim_trial = function(d, sigma,  barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=1000, ...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  RDV = bias
  time = 0
  elapsedNDT = 0
  choice = 0
  RT = NA
  kwargs = list(...)
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier | RDV <= -barrier){
      RT = (time * timeStep)/1000 #convert back to secs
      if (RDV >= barrier){
        choice = "left"
      } else if (RDV <= -barrier){
        choice = "right"
      }
      break
    } 
    
    # nonDecisionTime/timeStep gives how many sampling iterations the nonDecisionTime corresponds to
    # If elapsed time is less than the number of sampling iterations required for the nonDecisionTime set evidence sampling distribution mean to 0 so any move from starting point would only be noise
    if (elapsedNDT < nonDecisionTime / timeStep){
      mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      toUnpack = get_valDiff(EVLeft=kwargs$EVLeft, EVRight=kwargs$EVRight, QVLeft=kwargs$QVLeft, QVRight=kwargs$QVRight, probFractalDraw=kwargs$probFractalDraw)
      mean = d*toUnpack$valDiff
      out = toUnpack$out
    }
    
    # Sample the change in RDV from the distribution.
    RDV = RDV + rnorm(1, mean, sigma)
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #Organize output
  addToOut = data.frame(choice=choice, reactionTime = RT)
  out = cbind(out, addToOut)
  
  return(out)
}

get_valDiff = function(EVLeft, EVRight, QVLeft, QVRight, probFractalDraw){
  
  valueLeft = probFractalDraw*QVLeft + (1-probFractalDraw)*(EVLeft)
  valueRight = probFractalDraw*QVRight + (1-probFractalDraw)*(EVRight)
  valDiff= (valueLeft - valueRight)
  
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw)
  
  return(list(out=out, valDiff=valDiff))
}
```

Simulate one trial

```{r}
sim_trial(d=.02, sigma = .1, EVLeft=.5, EVRight = .5, QVLeft = 1.5, QVRight= .5 , probFractalDraw = 1)
```
Simulate task for one subject with their estimated QValues from the original model (with RPEs for both options on every trial)

Filter subject's data

```{r}
sub_data = clean_beh_data %>%
  filter(subnum == "01") %>%
  select(leftQValue, rightQValue, leftLotteryEV, rightLotteryEV, probFractalDraw, reactionTime, choiceLeft)

sub_data
```

Function to simulate data with the given EVs and QVs for the subject

```{r}
sim_task = function(sub_data, ...){
  
  kwargs = list(...)
  out = data.frame(EVLeft = NA, EVRight = NA, QVLeft = NA, QVRight = NA, probFractalDraw = NA, choice = NA, reactionTime = NA)
  
  for(i in 1:nrow(sub_data)) {
    
    cur_out = sim_trial(d=kwargs$d, sigma = kwargs$sigma, 
                        EVLeft=sub_data$leftLotteryEV[i], EVRight = sub_data$rightLotteryEV[i], 
                        QVLeft = sub_data$leftQValue[i], QVRight= sub_data$rightQValue[i] , 
                        probFractalDraw = sub_data$probFractalDraw[i])
    
    out = rbind(out, cur_out)
  }
  
  out = out %>% drop_na()
  
  return(out)
}
```

Simulate data for subject with given drift rate

```{r}
sim_sub_data = sim_task(sub_data = sub_data, d = .02, sigma = .1)
```

Compare simulated data to true data

```{r}
comp_df = sim_sub_data %>%
  mutate(choiceLeft = ifelse(choice=="left", 1, 0),
         data_type = "sim") %>%
  select(-choice) %>%
  rbind(sub_data %>%
          rename(EVLeft = leftLotteryEV, EVRight=rightLotteryEV, QVLeft=rightQValue, QVRight=leftQValue) %>%
          mutate(data_type="true"))
```

```{r}
comp_df %>%
  mutate(probFractalDraw = as.factor(probFractalDraw),
         log_rt = log(reactionTime)) %>%
  ggplot(aes(probFractalDraw, log_rt, fill=data_type))+
  geom_boxplot(position=position_dodge(width=.75))
```

What if you feed in all subjects' data

```{r}
sim_all_data = sim_task(sub_data = clean_beh_data, d = .02, sigma = .1)
```