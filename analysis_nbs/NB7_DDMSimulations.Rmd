---
title: "Experience vs. description based decision-making project: Adding arbitration to behavioral modeling"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

# Setup

Set up environment and load in data

```{r include=FALSE}
library(tidyverse)
library(gridExtra)
library(brms)
library(here)
library(broom)
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# theme_set(theme_bw())
theme_set(theme_classic())
sem <- function(x) {sd(x, na.rm=T) / sqrt(length(x))}
helpers_path = here('helpers/')

set.seed(385723)
```

Adding in parameters from the two systems model for all subjects (i.e. not choosing the best fitting one per subject)

```{r}
source(paste0(helpers_path,'fit_twoValSystemsWithRL_hierarchical.R'))
source(paste0(helpers_path,'add_inferred_pars.R'))
clean_beh_data = add_inferred_pars(clean_beh_data, par_ests, model_name="original")
source(paste0(helpers_path,'sim_task.R'))
source(paste0(helpers_path,'sim_sanity_checks.R'))
```

# True data

### Motivation for competition

```{r}
clean_beh_data %>%
  mutate(wAbsLeftEVAdv = (1-probFractalDraw)*abs(leftEVAdv),
         wAbsLeftQVAdv = (probFractalDraw)*abs(leftQVAdv),
         EVAdvMinQVAdv = abs(wAbsLeftEVAdv - wAbsLeftQVAdv),
         probFractalDraw = as.factor(probFractalDraw)) %>%
  group_by(probFractalDraw) %>%
  summarise(meanEVAdvMinQVAdv = mean(EVAdvMinQVAdv),
            semEVAdvMinQVAdv = sem(EVAdvMinQVAdv)) %>%
  ggplot(aes(probFractalDraw, meanEVAdvMinQVAdv))+
  geom_point()+
  geom_errorbar(aes(ymin = meanEVAdvMinQVAdv - semEVAdvMinQVAdv, ymax = meanEVAdvMinQVAdv + semEVAdvMinQVAdv), width=.2)
```

Filter data for a few subjects with a range of learning rates (i.e. variance in QValue differences) to simulate RTs using DDM. Rename columns to work with task simulation function. 

```{r}
sub_data = clean_beh_data %>%
  filter(subnum  %in% c("01", "03", "05","07", "09", "11", "13", "15", "17", "19")) %>%
  select(leftQValue, rightQValue, leftLotteryEV, rightLotteryEV, probFractalDraw, reactionTime, choiceLeft, subnum) %>%
  rename(EVLeft = leftLotteryEV, EVRight = rightLotteryEV, QVLeft = leftQValue, QVRight = rightQValue)
```

How do the sanity checks look in the sampled data?

```{r}
sim_sanity_checks(sub_data %>%
                    select(-subnum) %>%
                    mutate(choice = ifelse(choiceLeft == 1, "left", "right")), 
                  compare_rts = FALSE)
```

# Model 1: Integrate both starting at stim presentation

DDM that can take our task specific arguments as input

```{r}
sim_trial = function(d, sigma,  barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=1000, epsilon = 0.0002, ...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a (1000 iterations * 10 ms (per iteration) / 1000 convert back to sec =) 10sec timeout maximum
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier | RDV <= -barrier){
      RT = (time * timeStep)/1000 #convert back to secs
      if (RDV >= barrier){
        choice = "left"
      } else if (RDV <= -barrier){
        choice = "right"
      }
      break
    } 
    
    # nonDecisionTime/timeStep gives how many sampling iterations the nonDecisionTime corresponds to
    nonDecIters = nonDecisionTime / timeStep
    # If elapsed time is less than the number of sampling iterations required for the nonDecisionTime set evidence sampling distribution mean to 0 so any move from starting point would only be noise
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      # If the nonDecisionTime has passed set the mean of the distribution the decision variable will be sampled from to a value proportional to the value difference and the drift rate 
      valueLeft = probFractalDraw*QVLeft + (1-probFractalDraw)*(EVLeft)
      valueRight = probFractalDraw*QVRight + (1-probFractalDraw)*(EVRight)
      mu_mean = d*(valueLeft - valueRight)
    }
    
    # Sample the change in RDV from the distribution with mean proportional to the value difference
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT)
  return(out)
}
```

**NOTE on drift rate: with a value like d=0.002 there are too many timeout trials because the scale of the value difference is much smaller than e.g. the value difference in the aDDM papers**

```{r}
sim_data_m1_1 = sim_task(stimuli = sub_data, d = .01, sigma = .1)
```

```{r}
sim_sanity_checks(sim_data_m1_1)
```

Too fast with d=0.01. Can we slow it down with d=.005? Yes but then it's too noisy and choice doesn't depend on the relevant attributes as much as it should.

```{r}
sim_data_m1_2 = sim_task(stimuli = sub_data, d = .005, sigma = .1)
```

```{r}
sim_sanity_checks(sim_data_m1_2)
```

Error bars for RTs are very wide. Can we make them smaller with smaller sigma? (from .1 to .05)

```{r}
sim_data_m1_3 = sim_task(stimuli = sub_data, d = .005, sigma = .05)
```

```{r}
sim_sanity_checks(sim_data_m1_3)
```

# Model 2: Begin integration about Q values earlier if that is the only relevant option

```{r}
sim_trial = function(d, sigma, barrierDecay, barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=400, epsilon = 0.0002, stimDelay = 2000, evCompTime = 300, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  decPreStim = 0
  timeOut = 0
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  # Stimulus screen comes on 2 secs after the presentation of probFractalDraw
  stimDelayIters = stimDelay / timeStep
  nonDecIters = nonDecisionTime / timeStep
  evCompIters = evCompTime / timeStep
  
  # Integration starts before stim presentation (though meaningful move from 0 happens only for pFrac = 1 trials) but decision can only be indicated after stim. Since total iterations depend on maxIter the addition of iterations before stim presentation controls for the desired max time out for the trial. In the arguments to the function it is specified as the maximum time out duration after stim presentation
  maxIter = maxIter + stimDelayIters
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  # Barrier decay starts after stim presentation. Not during any possible sampling before that
  for(t in seq(stimDelayIters, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * (t-stimDelayIters))
  }
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier[time] | RDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      # Debugging
      if(debug){
        print(paste0("pre subtraction RT = ", RT))
      }
      
      #subtract stimDelay
      RT = RT - (stimDelay/1000) 
      
      # If decision is reached before the stim screen sample rt from log normal distribution similar to choice RT 
      if (RT < (stimDelay/1000)){
        if(debug){
          print("Sampling random RT")
        }
        decPreStim = 1
        RT=rlnorm(1, mean = -.25, sd = 0.5)
      }
      
      if (RDV >= barrier[time]){
        choice = "left"
      } else if (RDV <= -barrier[time]){
        choice = "right"
      }
      break
    } 
    
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      if (time < stimDelayIters){
        # Integration after fractal prob presentation but before stim presentation happens ONLY for the probfractaldraw == 1 trials
        if (probFractalDraw == 1){
          mu_mean = d*(QVLeft - QVRight)
          } else {
          # No integration after NDT and before stim presentation for any other trial type
          mu_mean = 0
          }
      } else{
        # integration for both attributes begins at stim presentation
        # valueLeft = probFractalDraw*QVLeft + (1-probFractalDraw)*(EVLeft)
        # valueRight = probFractalDraw*QVRight + (1-probFractalDraw)*(EVRight)
        # mu_mean = d*(valueLeft - valueRight)
        
        # Time for EV computation. Should create lottery bias
        if (time < (stimDelayIters + evCompIters)){
          mu_mean = d * (1-probFractalDraw) * (EVLeft - EVRight)
        } else {
          # Competition?
          # Gathering evidence based on lotteries vs fractals
          relPrefFractal =  probFractalDraw* (QVLeft - QVRight)
          relPrefLottery = (1-probFractalDraw) * (EVLeft - EVRight)
          relStrenLottery = abs(relPrefLottery)/(abs(relPrefFractal)+1e-6)
          mu_mean = d * (relPrefFractal + relStrenLottery * relPrefLottery)
          
          # How to get the inverse U?
        }
        
        
      }
    }
    
    # Sample the change in RDV from the distribution.
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    if (debug){
      print(paste0("time = ", time, " mu_mean = ", mu_mean, " mu = ", round(mu, 3), " RDV = ", round(RDV, 3), " barrier = ", round(barrier[time], 3)))
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    if (RDV >= 0){
        choice = "left"
      } else if (RDV <= 0){
        choice = "right"
      }
    if(debug){
      print("Max iterations reached.")
    }
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, decPreStim = decPreStim)
  return(out)
}
```

```{r}
sim_trial(d = .008, sigma = .01, barrierDecay = 0, EVLeft = 0.7, EVRight = .1, QVLeft = 0.7, QVRight = 0.1, probFractalDraw = .6, debug=TRUE)

t(replicate(20, sim_trial(d = .002, sigma = .01, barrierDecay = .003, EVLeft = 0.7, EVRight = .5, QVLeft = 0, QVRight = 0, probFractalDraw = 0.2, debug=FALSE), simplify = 'dataframe'))
```

```{r}
sim_data_m2_1 = sim_task(stimuli=sub_data, d = .005, sigma = .05, barrierDecay = 0.05)
```

```{r}
sim_sanity_checks(sim_data_m2_1)
```

```{r}
nrow(sub_data %>% filter(probFractalDraw==1))/nrow(sub_data)
```

```{r}
data.frame(val = rlnorm(1000, mean = -.25, sd = 0.5)) %>%
  ggplot(aes(val))+
  geom_histogram(bins = 30)
```

Things to incorporate:
- Choice bias for lotteries
- Computation of EV for lotteries takes time
- There is something other than EV computation going on for 1 > probFractalDraw > 0
- Competition based on relative strength of preference
