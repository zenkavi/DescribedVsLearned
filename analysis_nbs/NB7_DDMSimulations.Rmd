---
title: "Experience vs. description based decision-making project: Adding arbitration to behavioral modeling"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

# Setup

Set up environment and load in data

```{r include=FALSE}
library(tidyverse)
library(gridExtra)
library(brms)
library(here)
library(broom)
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# theme_set(theme_bw())
theme_set(theme_classic())
sem <- function(x) {sd(x, na.rm=T) / sqrt(length(x))}
helpers_path = here('helpers/')

set.seed(38573)
```

Adding in parameters from the two systems model for all subjects (i.e. not choosing the best fitting one per subject)

```{r}
source(paste0(helpers_path,'fit_twoValSystemsWithRL_hierarchical.R'))
source(paste0(helpers_path,'add_inferred_pars.R'))
clean_beh_data = add_inferred_pars(clean_beh_data, par_ests, model_name="original")
source(paste0(helpers_path,'sim_task.R'))
source(paste0(helpers_path,'sim_sanity_checks.R'))
source(paste0(helpers_path,'find_best_par_combo.R'))
```

# True data

### Motivation for competition

Graph below shows the difference in strength of preference for the left bundle based on EV versus QV. The smaller this difference the harder it should be to make the decision based on one attribute only. 

So if choice is faster when this value is larger that would suggest it is driven primarily by (the relative preference for) one attribute. Alternatively if choice is slower when this value is smaller it suggests integrating

```{r}
clean_beh_data %>%
  mutate(wAbsLeftEVAdv = (1-probFractalDraw)*abs(leftEVAdv), # strength of left preference based on EV
         wAbsLeftQVAdv = (probFractalDraw)*abs(leftQVAdv), # strength of left preference based on QV
         EVAdvMinQVAdv = abs(wAbsLeftEVAdv - wAbsLeftQVAdv), # difference in strength of preference
         probFractalDraw = as.factor(probFractalDraw)) %>%
  group_by(probFractalDraw) %>%
  summarise(meanEVAdvMinQVAdv = mean(EVAdvMinQVAdv),
            semEVAdvMinQVAdv = sem(EVAdvMinQVAdv)) %>%
  ggplot(aes(probFractalDraw, meanEVAdvMinQVAdv))+
  geom_point()+
  geom_errorbar(aes(ymin = meanEVAdvMinQVAdv - semEVAdvMinQVAdv, ymax = meanEVAdvMinQVAdv + semEVAdvMinQVAdv), width=.2)
```

Filter data for a few subjects with a range of learning rates (i.e. variance in QValue differences) to simulate RTs using DDM. Rename columns to work with task simulation function. 

```{r}
sub_data = clean_beh_data %>%
  filter(subnum  %in% c("01", "03", "05","07", "09", "11", "13", "15", "17", "19")) %>%
  select(leftQValue, rightQValue, leftLotteryEV, rightLotteryEV, probFractalDraw, reactionTime, choiceLeft, subnum) %>%
  rename(EVLeft = leftLotteryEV, EVRight = rightLotteryEV, QVLeft = leftQValue, QVRight = rightQValue)
```

## Sanity checks in the sampled data

```{r}
sim_sanity_checks(sub_data %>%
                    select(-subnum) %>%
                    mutate(choice = ifelse(choiceLeft == 1, "left", "right")), 
                  compare_rts = FALSE)
```

# Optimization prep

Create empty list that will store the trial simulators for the forthcoming models.

```{r}
sim_trial_list = list()
```

Define parameter space in which you'll search for best fits for the following models.

```{r}
d_par_space = c(.002, .004, .006, .008 ,.01, .02, .04, .06, .08, .1)
sigma_par_space = c(.004, .008 ,.01, .02, .04, .06, .08, .1)
```

# Model 1: Simplest

- Integration begins at stim presentation for all conditions
- Drift rate is proportional to the bundle value difference 
- Bundle values are computed as sums of QV and EV weighted by their relevance (no distortion of probability)

```{r}
sim_trial = function(d, sigma,  barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=400, epsilon = 0.0002, ...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a (1000 iterations * 10 ms (per iteration) / 1000 convert back to sec =) 10sec timeout maximum
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  # Initialize inputs
  kwargs = list(...)
  
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  
  valueLeft = probFractalDraw*QVLeft + (1-probFractalDraw)*(EVLeft)
  valueRight = probFractalDraw*QVRight + (1-probFractalDraw)*(EVRight)
  valDiff_mu_mean = d*(valueLeft - valueRight)
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier | RDV <= -barrier){
      RT = (time * timeStep)/1000 #convert back to secs
      if (RDV >= barrier){
        choice = "left"
      } else if (RDV <= -barrier){
        choice = "right"
      }
      break
    } 
    
    # nonDecisionTime/timeStep gives how many sampling iterations the nonDecisionTime corresponds to
    nonDecIters = nonDecisionTime / timeStep
    # If elapsed time is less than the number of sampling iterations required for the nonDecisionTime set evidence sampling distribution mean to 0 so any move from starting point would only be noise
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      # If the nonDecisionTime has passed set the mean of the distribution the decision variable will be sampled from to a value proportional to the value difference and the drift rate 
      mu_mean = valDiff_mu_mean
    }
    
    # Sample the change in RDV from the distribution with mean proportional to the value difference
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT)
  return(out)
}
sim_trial_list[['model1']] = sim_trial
```

## Opt pars

```{r}
m1_opt_out = find_best_par_combo(sub_data, model_name = "model1", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
sim_data_m1 = sim_w_best_combo(m1_opt_out, "model1")
```

```{r}
sim_sanity_checks(sim_data_m1$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m1$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m1$sim_data_opt_choice)
}
```

# Model 2: Early integration, relative preference weighting

- Two kinds of early integration
  - For probFractalDraw == 1 trials begin integrating before stimulus presentation proportional to QV difference weighted by drift rate
  - For all trials, if a decision hasn't already been made before the stim presentation, first integrate only based on the weighted EV difference. This is intended to capture EV computation at stim presentation and possibly result in a lottery bias
- Once any early integration is complete integration uses both QV and EV differences weighted by relevance. They are also weighted by how strong the difference on one attribute is compared to the other attribute.

```{r}
sim_trial = function(d, sigma, barrierDecay, barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=400, epsilon = 0.0002, stimDelay = 2000, evCompTime = 300, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  if (debug){
    debug_df = data.frame()
  }
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  decPreStim = 0
  timeOut = 0
  
  kwargs = list(...)
  
  d = kwargs$d
  sigma = kwargs$sigma
  barrier = kwargs$barrier
  barrierDecay = kwargs$barrierDecat 
  nonDecisionTime = kwargs$nonDecisionTime
  bias = kwargs$bias
  
  timestep = kwargs$timestep
  maxIter = kwargs$maxIter
  epsilon = kwargs$epsilon
  
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  # Stimulus screen comes on 2 secs after the presentation of probFractalDraw
  stimDelayIters = stimDelay / timeStep
  nonDecIters = nonDecisionTime / timeStep
  evCompIters = evCompTime / timeStep
  
  # Integration starts before stim presentation (though meaningful move from 0 happens only for pFrac = 1 trials) but decision can only be indicated after stim. Since total iterations depend on maxIter the addition of iterations before stim presentation controls for the desired max time out for the trial. In the arguments to the function it is specified as the maximum time out duration after stim presentation
  maxIter = maxIter + stimDelayIters
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  # Barrier decay starts after stim presentation. Not during any possible sampling before that
  for(t in seq(stimDelayIters, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * (t-stimDelayIters))
  }
  
  qv_mu_mean = d*(QVLeft - QVRight)
  ev_mu_mean = d * (1-probFractalDraw) * (EVLeft - EVRight)
  
  leftFractalAdv =  probFractalDraw* (QVLeft - QVRight)
  leftLotteryAdv = (1-probFractalDraw) * (EVLeft - EVRight)
  relPrefFractal = abs(leftFractalAdv)/(abs(leftLotteryAdv)+1e-6)
  weighted_mu_mean = d * (relPrefFractal * leftFractalAdv + (1/(relPrefFractal+1e-6)) * leftLotteryAdv)
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier[time] | RDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      # Debugging
      if(debug){
        print(paste0("pre subtraction RT = ", RT))
      }
      
      #subtract stimDelay
      RT = RT - (stimDelay/1000) 
      
      # If decision is reached before the stim screen sample rt from log normal distribution similar to choice RT 
      if (RT < 0){
        decPreStim = 1
        RT=rlnorm(1, mean = -.25, sd = 0.5)
      }
      
      if (RDV >= barrier[time]){
        choice = "left"
      } else if (RDV <= -barrier[time]){
        choice = "right"
      }
      break
    } 
    
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      if (time < stimDelayIters){
        # Integration after fractal prob presentation but before stim presentation happens ONLY for the probfractaldraw == 1 trials
        if (probFractalDraw == 1){
          mu_mean = qv_mu_mean
        } else {
          # No integration after NDT and before stim presentation for any other trial type
          mu_mean = 0
        }
      } else{
        # Time for EV computation. Should create lottery bias
        if (time < (stimDelayIters + evCompIters)){
          mu_mean = ev_mu_mean
        } else {
          # Competition?
          # Gathering evidence based on lotteries vs fractals
          mu_mean = weighted_mu_mean
        }
      }
    }
    
    # Sample the change in RDV from the distribution.
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    if (debug){
      debug_row = data.frame(time = time, mu_mean = mu_mean, mu = round(mu, 3), RDV = round(RDV, 3), barrier = round(barrier[time], 3))
      debug_df = rbind.all.columns(debug_df, debug_row)
      }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    if (RDV >= 0){
      choice = "left"
    } else if (RDV <= 0){
      choice = "right"
    }
    if(debug){
      print("Max iterations reached.")
    }
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, decPreStim = decPreStim, leftFractalAdv = leftFractalAdv, leftLotteryAdv = leftLotteryAdv,  relPrefFractal = relPrefFractal, relPrefLottery = 1/(relPrefFractal+1e-6), d = d, sigma = sigma, barrierDecay = barrierDecay)
  
  if(debug){
    return(list(out=out, debug_df = debug_df[-1,]))
  } else {
    return(out)
  }
}
sim_trial_list[['model2']] = sim_trial
```

## Opt pars

```{r}
m2_opt_out = find_best_par_combo(sub_data, model_name = "model2", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
sim_data_m2 = sim_w_best_combo(m2_opt_out, "model2")
```

```{r}
sim_sanity_checks(sim_data_m2$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m2$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m2$sim_data_opt_choice)
}
```

What is going on with the trials that hit decision before stimuli are presented but are not pfrac = 1? There should be no integration for these before the stimuli are presented. Seems to go down quickly with reducing sigma so they're likely from noise integration but reducing sigma messes up other things as well

```{r eval=FALSE, echo=FALSE}
sim_data_m2_opt_rt %>% 
  filter(decPreStim == 1)
```

# Model 3: Same as model 2 except for relative preference weighting

- Same two early integration possibilities
- For other cases the weighting factor is computed differently to mitigate effect of very large numbers at 0 difference between attributes

```{r}
sim_trial = function(d, sigma, barrierDecay, barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=400, epsilon = 0.0002, stimDelay = 2000, evCompTime = 300, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  if(debug){
    debug_df = data.frame()
  }
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  decPreStim = 0
  timeOut = 0
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  # Stimulus screen comes on 2 secs after the presentation of probFractalDraw
  stimDelayIters = stimDelay / timeStep
  nonDecIters = nonDecisionTime / timeStep
  evCompIters = evCompTime / timeStep
  
  # Integration starts before stim presentation (though meaningful move from 0 happens only for pFrac = 1 trials) but decision can only be indicated after stim. Since total iterations depend on maxIter the addition of iterations before stim presentation controls for the desired max time out for the trial. In the arguments to the function it is specified as the maximum time out duration after stim presentation
  maxIter = maxIter + stimDelayIters
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  # Barrier decay starts after stim presentation. Not during any possible sampling before that
  for(t in seq(stimDelayIters, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * (t-stimDelayIters))
  }
  
  qv_mu_mean = d*(QVLeft - QVRight)
  ev_mu_mean = d * (1-probFractalDraw) * (EVLeft - EVRight)
  leftFractalAdv =  probFractalDraw* (QVLeft - QVRight)
  leftLotteryAdv = (1-probFractalDraw) * (EVLeft - EVRight)
  relPrefFractal = abs(leftFractalAdv)/(abs(leftLotteryAdv)+abs(leftFractalAdv)+1e-6)
  weighted_mu_mean = d * (relPrefFractal * leftFractalAdv + (1-relPrefFractal) * leftLotteryAdv)

  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier[time] | RDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      #subtract stimDelay
      RT = RT - (stimDelay/1000) 
      
      # If decision is reached before the stim screen sample rt from log normal distribution similar to choice RT 
      if (RT < 0){
        decPreStim = 1
        RT=rlnorm(1, mean = -.25, sd = 0.5)
      }
      
      if (RDV >= barrier[time]){
        choice = "left"
      } else if (RDV <= -barrier[time]){
        choice = "right"
      }
      break
    } 
    
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      if (time < stimDelayIters){
        # Integration after fractal prob presentation but before stim presentation happens ONLY for the probfractaldraw == 1 trials
        if (probFractalDraw == 1){
          mu_mean = qv_mu_mean
        } else {
          # No integration after NDT and before stim presentation for any other trial type
          mu_mean = 0
        }
      } else{
        
        # Time for EV computation. Should create lottery bias
        if (time < (stimDelayIters + evCompIters)){
          mu_mean = ev_mu_mean
        } else {
          # Competition?
          # Gathering evidence based on lotteries vs fractals' relative strength of preference
          mu_mean = weighted_mu_mean
        }
      }
    }
    
    # Sample the change in RDV from the distribution.
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    if (debug){
      debug_row = data.frame(time = time, mu_mean = mu_mean, mu = round(mu, 3), RDV = round(RDV, 3), barrier = round(barrier[time], 3))
      debug_df = rbind.all.columns(debug_df, debug_row)
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    if (RDV >= 0){
      choice = "left"
    } else if (RDV <= 0){
      choice = "right"
    }
    if(debug){
      print("Max iterations reached.")
    }
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, decPreStim = decPreStim, leftFractalAdv = leftFractalAdv, leftLotteryAdv = leftLotteryAdv,  relPrefFractal = relPrefFractal, d = d, sigma = sigma, barrierDecay = barrierDecay, barrier = barrier[time], RDV = RDV)
  
  if(debug){
    return(list(out=out, debug_df=debug_df))
  }else{
    return(out)
  }
  
}
sim_trial_list[['model3']] = sim_trial
```

## Opt pars

```{r}
m3_opt_out = find_best_par_combo(sub_data, model_name = "model3", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
sim_data_m3 = sim_w_best_combo(m3_opt_out, "model3")
```

```{r}
sim_sanity_checks(sim_data_m3$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m3$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m3$sim_data_opt_choice)
}

```

# Model 4: 3 integrators

- all biases are by moving the starting points
  - for all trials there is a general lottery bias
  - for pfrac == 1 trials there is a fractal bias the size of the QV difference
- Integration happens for EV and QV separately along with an arbitrator that determines the decision

```{r}
sim_trial = function(dArb, dAttr, sigmaArb, sigmaAttr, barrierDecay, barrier=1, nonDecisionTime=0, lotteryBias=0.1, fractalBias = 0, timeStep=10, maxIter=400, epsilon = 0.002, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  
  arbitratorRDV = 0
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  timeOut = 0
  
  arbitrator_mu_mean = NA
  if(debug){
    debug_df = data.frame()
  }
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  if(EVLeft > EVRight){
    lotteryRDV = lotteryBias
  } else {
    lotteryRDV = -lotteryBias
  }
  
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  if(QVLeft > QVRight){
    fractalRDV = fractalBias
  } else {
    fractalRDV = -fractalBias
  }
  
  probFractalDraw=kwargs$probFractalDraw
  if(probFractalDraw == 1){
    fractalRDV = QVLeft - QVRight
  }
  
  nonDecIters = nonDecisionTime / timeStep
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  for(t in seq(1, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * t)
  }
  
  lottery_mu_mean = dAttr * (1-probFractalDraw) * (EVLeft - EVRight)
  fractal_mu_mean = dAttr * probFractalDraw * (QVLeft - QVRight)
  
  while (time<maxIter){
    
    # If the arbitrator RDV hits one of the barriers make decision
    if (arbitratorRDV >= barrier[time] | arbitratorRDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      if (arbitratorRDV >= barrier[time]){
        arbitrator = "EV"
        choice = ifelse(lotteryRDV > 0, "left", "right")
      } else if (arbitratorRDV <= -barrier[time]){
        arbitrator = "QV"
        choice = ifelse(fractalRDV > 0, "left", "right")
      }
      break
    } 
    
    # Otherwise continue sampling evidence
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      
      # Three integrators
      
      # Lottery integrator
      lottery_mu = rnorm(1, lottery_mu_mean, epsilon)
      lotteryRDV = lotteryRDV + rnorm(1, lottery_mu, sigmaAttr)
      
      # Fractal integrator
      fractal_mu = rnorm(1, fractal_mu_mean, epsilon)
      fractalRDV = fractalRDV + rnorm(1, fractal_mu, sigmaAttr)
      
      # Arbitrator 
      # If abs(lotteryRDV) > abs(fractalRDV) stronger relative preference for a side based on lotteries
      arbitrator_mu_mean = dArb * (abs(lotteryRDV) - abs(fractalRDV))
      arbitrator_mu = rnorm(1, arbitrator_mu_mean, epsilon)
      arbitratorRDV = arbitratorRDV + rnorm(1, arbitrator_mu, sigmaArb)
    }
    
    if (debug){
      debug_row = data.frame(time = time, arbitrator_mu_mean = round(arbitrator_mu_mean, 3), arbitratorRDV = round(arbitratorRDV, 3), barrier = round(barrier[time], 3), lotteryRDV = round(lotteryRDV, 3), fractalRDV = round(fractalRDV, 3))
      debug_df = rbind(debug_df, debug_row)
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    arbitrator = ifelse(arbitratorRDV >= 0 , "EV", "QV")
    if(arbitrator == "EV"){
      choice = ifelse(lotteryRDV > 0, "left", "right")
    } else if (arbitrator == "QV"){
      choice = ifelse(fractalRDV > 0, "left", "right")
    }
   
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, arbitrator = arbitrator)
  
  if(debug){
    out = list(out=out, debug_df=debug_df[-1,])
  }
  
  return(out)
}
sim_trial_list[['model4']] = sim_trial
```

Example visualization of integration

```{r echo=FALSE, eval=FALSE}
tmp = sim_trial(d = .033, sigma = .03, barrierDecay = 0.005, EVLeft = .7, EVRight = 0.5, QVLeft = 0.3, QVRight = 0.7, probFractalDraw = .8, debug=TRUE, nonDecisionTime = 0)

tmp$debug_df %>%
  select(-arbitrator_mu_mean) %>%
  gather(key, value, -time, -barrier) %>%
  ggplot()+
  geom_line(aes(time, value))+
  geom_line(aes(time, barrier), color="red")+
  geom_line(aes(time, -barrier), color="green")+
  geom_hline(aes(yintercept = 0), linetype="dashed")+
  facet_grid(key ~.)
```

## Opt pars

```{r}
m4_opt_out = find_best_par_combo(sub_data, model_name = "model4", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
summarise_opt_out(m4_opt_out)
```

```{r}
m4_opt_out %>%
  select(rt_sumsq, choice_sumsq) %>%
  gather(key, value) %>%
  ggplot(aes(value, fill=key)) +
  geom_histogram(position="identity", alpha=.5, bins=30) +
  theme(legend.position = "bottom")+
  labs(fill="")
```

```{r}
sim_data_m4 = sim_w_best_combo(m4_opt_out, "model4")
```

```{r}
sim_sanity_checks(sim_data_m4$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m4$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m4$sim_data_opt_choice)
}

```

# Model 5: 3 integrators

- Same as model 4 but with attribute relevance affecting arbitrator and not the attribute integrators

```{r}
sim_trial = function(dArb, dAttr, sigmaArb, sigmaAttr, barrierDecay, barrier=1, nonDecisionTime=0, lotteryBias=0.1, fractalBias = 0, timeStep=10, maxIter=400, epsilon = 0.002, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  
  arbitratorRDV = 0
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  timeOut = 0
  
  arbitrator_mu_mean = NA
  if(debug){
    debug_df = data.frame()
  }
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  if(EVLeft > EVRight){
    lotteryRDV = lotteryBias
  } else {
    lotteryRDV = -lotteryBias
  }
  
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  if(QVLeft > QVRight){
    fractalRDV = fractalBias
  } else {
    fractalRDV = -fractalBias
  }
  
  probFractalDraw=kwargs$probFractalDraw
  if(probFractalDraw == 1){
    fractalRDV = QVLeft - QVRight
  }
  
  nonDecIters = nonDecisionTime / timeStep
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  for(t in seq(1, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * t)
  }
  
  lottery_mu_mean = dAttr * (EVLeft - EVRight)
  fractal_mu_mean = dAttr * (QVLeft - QVRight)
  
  while (time<maxIter){
    
    # If the arbitrator RDV hits one of the barriers make decision
    if (arbitratorRDV >= barrier[time] | arbitratorRDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      if (arbitratorRDV >= barrier[time]){
        arbitrator = "EV"
        choice = ifelse(lotteryRDV > 0, "left", "right")
      } else if (arbitratorRDV <= -barrier[time]){
        arbitrator = "QV"
        choice = ifelse(fractalRDV > 0, "left", "right")
      }
      break
    } 
    
    # Otherwise continue sampling evidence
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      
      # Three integrators
      
      # Lottery integrator
      lottery_mu = rnorm(1, lottery_mu_mean, epsilon)
      lotteryRDV = lotteryRDV + rnorm(1, lottery_mu, sigmaAttr)
      
      # Fractal integrator
      fractal_mu = rnorm(1, fractal_mu_mean, epsilon)
      fractalRDV = fractalRDV + rnorm(1, fractal_mu, sigmaAttr)
      
      # Arbitrator 
      # If abs(lotteryRDV) > abs(fractalRDV) stronger relative preference for a side based on lotteries
      arbitrator_mu_mean = dArb * ((1-probFractalDraw) * abs(lotteryRDV) - (probFractalDraw) * abs(fractalRDV))
      arbitrator_mu = rnorm(1, arbitrator_mu_mean, epsilon)
      arbitratorRDV = arbitratorRDV + rnorm(1, arbitrator_mu, sigmaArb)
    }
    
    if (debug){
      debug_row = data.frame(time = time, arbitrator_mu_mean = round(arbitrator_mu_mean, 3), arbitratorRDV = round(arbitratorRDV, 3), barrier = round(barrier[time], 3), lotteryRDV = round(lotteryRDV, 3), fractalRDV = round(fractalRDV, 3))
      debug_df = rbind(debug_df, debug_row)
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    arbitrator = ifelse(arbitratorRDV >= 0 , "EV", "QV")
    if(arbitrator == "EV"){
      choice = ifelse(lotteryRDV > 0, "left", "right")
    } else if (arbitrator == "QV"){
      choice = ifelse(fractalRDV > 0, "left", "right")
    }
   
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, arbitrator = arbitrator)
  
  if(debug){
    out = list(out=out, debug_df=debug_df)
  }
  
  return(out)
}
sim_trial_list[['model5']] = sim_trial
```

Example visualization of integration

```{r echo=FALSE, eval=FALSE}
tmp = sim_trial(dArb = .04, dAttr=0.1, sigmaArb = .02, sigmaAttr = .01, barrierDecay = 0, EVLeft = .7, EVRight = 0.5, QVLeft = 0, QVRight = 0, probFractalDraw = .8, debug=TRUE, nonDecisionTime = 0)

tmp$debug_df %>%
  select(-arbitrator_mu_mean) %>%
  gather(key, value, -time, -barrier) %>%
  ggplot()+
  geom_line(aes(time, value))+
  geom_line(aes(time, barrier), color="red")+
  geom_line(aes(time, -barrier), color="green")+
  geom_hline(aes(yintercept = 0), linetype="dashed")+
  facet_grid(key ~.)+
  theme_bw()
```

```{r}
tmp
```

```{r}
replicate(4, sim_trial_list[['model5']](dArb = .04, dAttr=0.1, sigmaArb = .02, sigmaAttr = .01, barrierDecay = 0, EVLeft = .6, EVRight = 0.5, QVLeft = 0, QVRight = 0, probFractalDraw = 0, nonDecisionTime = 0))
```

## Opt pars

```{r}
m5_opt_out = find_best_par_combo(sub_data, model_name = "model5", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
summarise_opt_out(m5_opt_out)
```

```{r}
sim_data_m5 = sim_w_best_combo(m5_opt_out, "model5")
```

```{r}
sim_sanity_checks(sim_data_m5$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m5$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m5$sim_data_opt_choice)
}

```

# Trade-offs across models

- Is the relationship between pars that optim rt vs choice the same across models?

No. There can be a trade-off between the parameters depending on what you optimize for but it's not in the same direction for all models.

```{r}
all_opt_outs = list(m1_opt_out, m2_opt_out, m3_opt_out, m4_opt_out, m5_opt_out)
opt_outs_df = data.frame()
for (i in 1:length(all_opt_outs)){
  opt_outs_df = rbind.all.columns(opt_outs_df,
                                  all_opt_outs[[i]]$opt_rt_pars %>%
                                    mutate(model_name = paste0("model", i),
                                           opt_for = "opt_rt") %>%
                                    rbind(all_opt_outs[[i]]$opt_choice_pars %>%
                                            mutate(model_name = paste0("model", i),
                                                   opt_for = "opt_choice")) %>%
                                    rbind(all_opt_outs[[i]]$opt_avg_pars %>%
                                            mutate(model_name = paste0("model", i),
                                                   opt_for = "opt_avg")))
}

opt_outs_df %>%
  select(-barrier_decay, -rt_sumsq, -choice_sumsq, -avg_sumsq) %>%
  gather(par, value, -model_name, -opt_for) %>%
  ggplot(aes(model_name, value, color=opt_for))+
  geom_point(size=4, alpha=.5)+
  facet_wrap(~par)+
  labs(x="", y="", color="")+
  theme(legend.position = "bottom")
```
```{r}
opt_outs_df
```

# Next steps

- Incorporating EV and QV computation instead of using them as input
