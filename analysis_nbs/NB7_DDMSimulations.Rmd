---
title: "Experience vs. description based decision-making project: Adding arbitration to behavioral modeling"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

Set up environment and load in data

```{r include=FALSE}
library(tidyverse)
library(gridExtra)
library(brms)
library(here)
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# theme_set(theme_bw())
theme_set(theme_classic())
sem <- function(x) {sd(x, na.rm=T) / sqrt(length(x))}
helpers_path = here('helpers/')

set.seed(385723)
```

Adding in parameters from the two systems model for all subjects (i.e. not choosing the best fitting one per subject)

```{r}
source(paste0(helpers_path,'fit_twoValSystemsWithRL_hierarchical.R'))
source(paste0(helpers_path,'add_inferred_pars.R'))
clean_beh_data = add_inferred_pars(clean_beh_data, par_ests, model_name="original")
```

Helper function that loops provided task conditions to generate simulated trials

```{r}
sim_task = function(sub_data, ...){
  kwargs = list(...)
  if (!("nonDecisionTime" %in% kwargs)){
    kwargs$nonDecisionTime = 0
  }
  
  # Create placeholder output df
  out = data.frame(EVLeft = NA, EVRight = NA, QVLeft = NA, QVRight = NA, probFractalDraw = NA, choice = NA, reactionTime = NA)
  
  # Loop through all trials of a subjects data (or just all the rows of the input)
  for(i in 1:nrow(sub_data)) {
    
    # Simulate RT and choice for a single trial with given DDM parameters and trial stimulus values
    cur_out = sim_trial(d=kwargs$d, sigma = kwargs$sigma, nonDecisionTime = kwargs$nonDecisionTime,
                        EVLeft=sub_data$leftLotteryEV[i], EVRight = sub_data$rightLotteryEV[i], 
                        QVLeft = sub_data$leftQValue[i], QVRight= sub_data$rightQValue[i] , 
                        probFractalDraw = sub_data$probFractalDraw[i])
    
    # Append the trial to the rest of the output
    out = rbind(out, cur_out)
    
  }
  
  # Drops only first row instead of all NAs to keep trials where iterations timed out and a decision was not made
  out = out[-1,]
  
  return(out)
}
```

## Model 1:

DDM that can take our task specific arguments as input

```{r}
sim_trial = function(d, sigma,  barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=1000, ...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a (1000 iterations * 10 ms (per iteration) / 1000 convert back to sec =) 10sec timeout maximum
  
  RDV = bias
  time = 0
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier | RDV <= -barrier){
      RT = (time * timeStep)/1000 #convert back to secs
      if (RDV >= barrier){
        choice = "left"
      } else if (RDV <= -barrier){
        choice = "right"
      }
      break
    } 
    
    # nonDecisionTime/timeStep gives how many sampling iterations the nonDecisionTime corresponds to
    nonDecIters = nonDecisionTime / timeStep
    # If elapsed time is less than the number of sampling iterations required for the nonDecisionTime set evidence sampling distribution mean to 0 so any move from starting point would only be noise
    if (elapsedNDT < nonDecIters){
      mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      # If the nonDecisionTime has passed set the mean of the distribution the decision variable will be sampled from to a value proportional to the value difference and the drift rate 
      valueLeft = probFractalDraw*QVLeft + (1-probFractalDraw)*(EVLeft)
      valueRight = probFractalDraw*QVRight + (1-probFractalDraw)*(EVRight)
      mean = d*(valueLeft - valueRight)
    }
    
    # Sample the change in RDV from the distribution with mean proportional to the value difference
    RDV = RDV + rnorm(1, mean, sigma)
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT)
  return(out)
}
```

```{r echo=FALSE}
# Test function by simulating one trial
# sim_trial(d=.01, sigma = .05, EVLeft=.5, EVRight = .5, QVLeft = 1.5, QVRight= .5 , probFractalDraw = 1, nonDecisionTime=300)
```

Filter data for a few subjects with a range of learning rates (i.e. variance in QValue differences) to simulate RTs using DDM 

```{r}
sub_data = clean_beh_data %>%
  filter(subnum == "01" | subnum == "10" | subnum == "19") %>%
  select(leftQValue, rightQValue, leftLotteryEV, rightLotteryEV, probFractalDraw, reactionTime, choiceLeft, subnum)

# sub_data
```

Simulate data for filtered subjects with same DDM parameters for everyone

```{r}
sim_sub_data1 = sim_task(sub_data = sub_data, d = .02, sigma = .02, nonDecisionTime = 0)
```

Sanity checks for simulated data.

Proportion of trials without choice. Too high when d = .002 so reduced it by an order of magnitude. Even then it is higher than actual data.

```{r}
sum(is.na(sim_sub_data1$reactionTime))/nrow(sim_sub_data1)
```

Does choice relate to value difference sensibly (psychometric curve)

```{r}
sim_sub_data1 %>%
  filter(probFractalDraw == 0 | probFractalDraw == 1) %>%
  mutate(choiceLeft =ifelse(choice == "left", 1, ifelse(choice == "right", 0, NA))) %>%
  mutate(EVLeftMinRight = EVLeft - EVRight,
         QVLeftMinRight = QVLeft - QVRight) %>%
  select(-choice, -EVLeft, -EVRight, -QVLeft, -QVRight) %>%
  gather(key, value, -probFractalDraw, -reactionTime, -choiceLeft) %>%
  ggplot(aes(value, choiceLeft))+
  geom_jitter(height = .1)+
  geom_smooth(formula = 'y~x', method = "glm", method.args = list(family=binomial), fullrange=TRUE, alpha=.1)+
  facet_grid(key ~ probFractalDraw)

```

Distribution of RTs for each probFractalDraw. Is the standard long tail there?

```{r}
sim_sub_data1 %>%
  mutate(probFractalDraw = as.factor(probFractalDraw)) %>%
  ggplot(aes(reactionTime, fill=probFractalDraw)) +
  geom_histogram(postion="identity", bins=30) +
  theme(legend.position="bottom")+
  guides(fill=guide_legend(nrow=2,byrow=TRUE))
```

Inverse U of RTs with probFractalDraw and categorically faster RTs when probFractalDraw == 1

```{r}
sim_sub_data1 %>%
  drop_na()%>%
  mutate(probFractalDraw = as.factor(probFractalDraw), 
         log_rt = log(reactionTime)) %>%
  group_by(probFractalDraw) %>%
  summarise(mean_log_rt = mean(log_rt),
            sem_log_rt = sem(log_rt)) %>%
  ggplot(aes(probFractalDraw, mean_log_rt))+
  geom_point()+
  geom_errorbar(aes(ymin = mean_log_rt - sem_log_rt, ymax = mean_log_rt + sem_log_rt), width=.2)
```

## Model 2:

Start integrating about the fractals before the stimulus screen is presented

```{r}
sim_trial = function(d, sigma,  barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=1000, ...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  RDV = bias
  time = 0
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  stimDelay = 2000 #Stimulus screen comes on 2 secs after the presentation of probFractalDraw
  stimDelayIters = stimDelay / timeStep
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier | RDV <= -barrier){
      RT = (time * timeStep)/1000 #convert ms back to secs
      
      # if (RT<stimDelay/1000){
      #   RT=nonDecisionTime
      # }
      
      if (RDV >= barrier){
        choice = "left"
      } else if (RDV <= -barrier){
        choice = "right"
      }
      break
    } 
    
    # Stim hasn't been presented yet
    # integration begins using only QVs
    if (time < stimDelayIters){
      mean = d*probFractalDraw*(QVLeft - QVRight)
    } else{ 
      if (elapsedNDT < (nonDecisionTime / timeStep)){
        mean = 0
        elapsedNDT = elapsedNDT + 1
        } else{
          # stim has been presented. integration of both attributes continues
          valueLeft = probFractalDraw*QVLeft + (1-probFractalDraw)*(EVLeft)
          valueRight = probFractalDraw*QVRight + (1-probFractalDraw)*(EVRight)
          mean = d*(valueLeft - valueRight)
        }
      
    }
    
    
    # Sample the change in RDV from the distribution.
    RDV = RDV + rnorm(1, mean, sigma)
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT)
  return(out)
}
```

Simulate data for filtered subjects with same DDM parameters for everyone

```{r}
sim_sub_data2 = sim_task(sub_data = sub_data, d = .002, sigma = .02, nonDecisionTime = 150)
```

Can we replicate the patterns in the true data?

```{r}

```

```{r}
sim_sub_data2 %>%
  filter(probFractalDraw == 0) %>%
  mutate(QVDiff = QVLeft-QVRight)%>%
  ggplot(aes(QVDiff, reactionTime))+
  geom_point()
```