---
title: "Experience vs. description based decision-making project: Adding arbitration to behavioral modeling"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

# Setup

Set up environment and load in data

```{r include=FALSE}
library(tidyverse)
library(gridExtra)
library(brms)
library(here)
library(broom)
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# theme_set(theme_bw())
theme_set(theme_classic())
sem <- function(x) {sd(x, na.rm=T) / sqrt(length(x))}
helpers_path = here('helpers/')

set.seed(38573)
```

Adding in parameters from the two systems model for all subjects (i.e. not choosing the best fitting one per subject)

```{r}
source(paste0(helpers_path,'twoSystemsFitting/fit_twoValSystemsWithRL_hierarchical.R'))
source(paste0(helpers_path,'add_inferred_pars.R'))
clean_beh_data = add_inferred_pars(clean_beh_data, par_ests, model_name="original")
source(paste0(helpers_path,'ddmSims/sim_task.R'))
source(paste0(helpers_path,'ddmSims/sim_sanity_checks.R'))
source(paste0(helpers_path,'ddmSims/find_best_par_combo.R'))
```

# True data

### Motivation for competition

Graph below shows the difference in strength of preference for the left bundle based on EV versus QV. The smaller this difference the harder it should be to make the decision based on one attribute only. 

So if choice is faster when this value is larger that would suggest it is driven primarily by (the relative preference for) one attribute. Alternatively if choice is slower when this value is smaller it suggests integrating

```{r}
clean_beh_data %>%
  mutate(wAbsLeftEVAdv = (1-probFractalDraw)*abs(leftEVAdv), # strength of left preference based on EV
         wAbsLeftQVAdv = (probFractalDraw)*abs(leftQVAdv), # strength of left preference based on QV
         EVAdvMinQVAdv = abs(wAbsLeftEVAdv - wAbsLeftQVAdv), # difference in strength of preference
         probFractalDraw = as.factor(probFractalDraw)) %>%
  group_by(probFractalDraw) %>%
  summarise(meanEVAdvMinQVAdv = mean(EVAdvMinQVAdv),
            semEVAdvMinQVAdv = sem(EVAdvMinQVAdv)) %>%
  ggplot(aes(probFractalDraw, meanEVAdvMinQVAdv))+
  geom_point()+
  geom_errorbar(aes(ymin = meanEVAdvMinQVAdv - semEVAdvMinQVAdv, ymax = meanEVAdvMinQVAdv + semEVAdvMinQVAdv), width=.2)
```

Filter data for a few subjects with a range of learning rates (i.e. variance in QValue differences) to simulate RTs using DDM. Rename columns to work with task simulation function. 

```{r}
sub_data = clean_beh_data %>%
  filter(subnum  %in% c("01", "03", "05","07", "09", "11", "13", "15", "17", "19")) %>%
  select(leftQValue, rightQValue, leftLotteryEV, rightLotteryEV, probFractalDraw, reactionTime, choiceLeft, subnum) %>%
  rename(EVLeft = leftLotteryEV, EVRight = rightLotteryEV, QVLeft = leftQValue, QVRight = rightQValue)
```

## Sanity checks in the sampled data

```{r}
sim_sanity_checks(sub_data %>%
                    select(-subnum) %>%
                    mutate(choice = ifelse(choiceLeft == 1, "left", "right")), 
                  compare_rts = FALSE)
```

# Optimization prep

Create empty list that will store the trial simulators for the forthcoming models.

```{r}
sim_trial_list = list()
```

Define parameter space in which you'll search for best fits for the following models.

```{r}
d_par_space = c(.002, .004, .006, .008 ,.01, .02, .04, .06, .08, .1)
sigma_par_space = c(.004, .008 ,.01, .02, .04, .06, .08, .1)
```

# Model 1: Simplest

- Integration begins at stim presentation for all conditions
- Drift rate is proportional to the bundle value difference 
- Bundle values are computed as sums of QV and EV weighted by their relevance (no distortion of probability)

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model1.R'))
sim_trial_list[['model1']] = sim_trial
```

## Check sim task 

```{r eval = FALSE, echo = FALSE}
tmp = sim_task(sub_data, model_name="model1", d=0.04, sigma = 0.02)
sim_sanity_checks(tmp)
```

### What controls spread vs mean?

```{r}
tmp1 = sim_task(sub_data, model_name = "model1", d=0.06, sigma = 0.03)
sim_sanity_checks(tmp1, checks=c(3))
```

```{r}
tmp2 = sim_task(sub_data, model_name = "model1", d=0.06, sigma = 0.003)
sim_sanity_checks(tmp2, checks=c(3))
```

```{r}
tmp3 = sim_task(sub_data, model_name = "model1", d=0.006, sigma = 0.03)
sim_sanity_checks(tmp3, checks=c(3))
```

```{r}
tmp4 = sim_task(sub_data, model_name = "model1", d=0.006, sigma = 0.003)
sim_sanity_checks(tmp4, checks=c(3))
```

```{r}
rm(tmp1, tmp2, tmp3, tmp4)
```

## Opt pars

```{r}
m1_opt_out = find_best_par_combo(sub_data, model_name = "model1", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
sim_data_m1 = sim_w_best_combo(m1_opt_out, "model1")
```

```{r}
sim_sanity_checks(sim_data_m1$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m1$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m1$sim_data_opt_choice)
}
```

# Model 2: Early integration

- For probFractalDraw == 1 trials begin integrating before stimulus presentation proportional to QV difference weighted by drift rate
- Once early integration is complete integration uses both QV and EV differences weighted by relevance

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model2.R'))
sim_trial_list[['model2']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model2", d=0.04, sigma = 0.03)
sim_sanity_checks(tmp)
```

When does integration reach a bound before the stim presentation?

```{r}
with(tmp, table(decPreStim, probFractalDraw))
```

```{r}
tmp %>%
  select(EVLeft, EVRight, QVLeft, QVRight, probFractalDraw, choice, reactionTime, decPreStim) %>%
  mutate(data_type = "sim") %>%
  rbind(sub_data %>%
          mutate(choice = ifelse(choiceLeft == 1, "left", "right"),
                 data_type = "true",
                 decPreStim = "trueData") %>%
          select(-subnum, -choiceLeft)) %>%
  mutate(probFractalDraw = as.factor(probFractalDraw)) %>%
  ggplot(aes(reactionTime, fill=decPreStim)) +
  geom_histogram(position="identity", bins=30, alpha=.5) +
  facet_wrap(~probFractalDraw)+
  theme(legend.position = "bottom")
```

## Opt pars

```{r}
m2_opt_out = find_best_par_combo(sub_data, model_name = "model2", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
sim_data_m2 = sim_w_best_combo(m2_opt_out, "model2")
```

```{r}
sim_sanity_checks(sim_data_m2$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m2$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m2$sim_data_opt_choice)
}
```

# Model 3: Model 2 + relative preference weighting

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model3.R'))
sim_trial_list[['model3']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model3", d=0.05, sigma = 0.01)
sim_sanity_checks(tmp)
```

## Opt pars

```{r}
m3_opt_out = find_best_par_combo(sub_data, model_name = "model3", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
sim_data_m3 = sim_w_best_combo(m3_opt_out, "model3")
```

```{r}
sim_sanity_checks(sim_data_m3$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m3$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m3$sim_data_opt_choice)
}

```

# Model 4: 3 integrators

- all biases are by moving the starting points
  - for all trials there is a general lottery bias
  - for pfrac == 1 trials there is a fractal bias the size of the QV difference
- Integration happens for EV and QV separately along with an arbitrator that determines the decision

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model4.R'))
sim_trial_list[['model4']] = sim_trial
```

Example visualization of integration

```{r echo=FALSE, eval=FALSE}
tmp = sim_trial(d = .033, sigma = .03, barrierDecay = 0.005, EVLeft = .7, EVRight = 0.5, QVLeft = 0.3, QVRight = 0.7, probFractalDraw = .8, debug=TRUE, nonDecisionTime = 0)

tmp$debug_df %>%
  select(-arbitrator_mu_mean) %>%
  gather(key, value, -time, -barrier) %>%
  ggplot()+
  geom_line(aes(time, value))+
  geom_line(aes(time, barrier), color="red")+
  geom_line(aes(time, -barrier), color="green")+
  geom_hline(aes(yintercept = 0), linetype="dashed")+
  facet_grid(key ~.)
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model4", dAttr=0.04, dArb=0.04, sigmaAttr = 0.03, sigmaArb = 0.03)
sim_sanity_checks(tmp)
```

## Opt pars

```{r}
m4_opt_out = find_best_par_combo(sub_data, model_name = "model4", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
summarise_opt_out(m4_opt_out)
```

```{r}
m4_opt_out %>%
  select(rt_sumsq, choice_sumsq) %>%
  gather(key, value) %>%
  ggplot(aes(value, fill=key)) +
  geom_histogram(position="identity", alpha=.5, bins=30) +
  theme(legend.position = "bottom")+
  labs(fill="")
```

```{r}
sim_data_m4 = sim_w_best_combo(m4_opt_out, "model4")
```

```{r}
sim_sanity_checks(sim_data_m4$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m4$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m4$sim_data_opt_choice)
}

```

# Model 5: 3 integrators

- Same as model 4 but with attribute relevance affecting arbitrator and not the attribute integrators

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model5.R'))
sim_trial_list[['model5']] = sim_trial
```

Example visualization of integration

```{r echo=FALSE, eval=FALSE}
tmp = sim_trial(dArb = .04, dAttr=0.1, sigmaArb = .02, sigmaAttr = .01, barrierDecay = 0, EVLeft = .7, EVRight = 0.5, QVLeft = 0, QVRight = 0, probFractalDraw = .8, debug=TRUE, nonDecisionTime = 0)

tmp$debug_df %>%
  select(-arbitrator_mu_mean) %>%
  gather(key, value, -time, -barrier) %>%
  ggplot()+
  geom_line(aes(time, value))+
  geom_line(aes(time, barrier), color="red")+
  geom_line(aes(time, -barrier), color="green")+
  geom_hline(aes(yintercept = 0), linetype="dashed")+
  facet_grid(key ~.)+
  theme_bw()
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model5", dAttr=0.04, dArb=0.04, sigmaAttr = 0.03, sigmaArb = 0.03)
sim_sanity_checks(tmp)
```

```{r}
tmp %>%
  select(EVLeft, EVRight, QVLeft, QVRight, probFractalDraw, choice, reactionTime, arbitrator) %>%
  mutate(data_type = "sim") %>%
  rbind(sub_data %>%
          mutate(choice = ifelse(choiceLeft == 1, "left", "right"),
                 data_type = "true",
                 arbitrator= "true") %>%
          select(-subnum, -choiceLeft)) %>%
  mutate(probFractalDraw = as.factor(probFractalDraw)) %>%
  ggplot(aes(reactionTime, fill=as.factor(arbitrator))) +
  geom_histogram(position="identity", bins=30, alpha=.5) +
  labs(title="RT long tail?", fill="")+
  facet_wrap(~probFractalDraw)+
  theme(legend.position = "bottom")
```

## Opt pars

```{r}
m5_opt_out = find_best_par_combo(sub_data, model_name = "model5", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
summarise_opt_out(m5_opt_out)
```

```{r}
sim_data_m5 = sim_w_best_combo(m5_opt_out, "model5")
```

```{r}
sim_sanity_checks(sim_data_m5$sim_data_opt_rt)
```

```{r}
summarise_opt_out(m5_opt_out)
```

```{r}
if(is.na(sim_data_m5$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m5$sim_data_opt_choice)
}

```

How to visualize goodness of fit across

```{r}
m5_opt_out %>% 
  select(rt_sumsq, choice_sumsq) %>%
  mutate(choice_sumsq = ifelse(choice_sumsq>500, 500, choice_sumsq)) %>%
  gather(key, value) %>%
  ggplot(aes(value))+
  geom_histogram(position="identity", alpha = .5, bins=30) +
  facet_wrap(~key, scales="free")
```

```{r}
m5_opt_out %>%
  mutate(choice_sumsq = ifelse(choice_sumsq>500, 500, choice_sumsq)) %>%
  select(-rt_sumsq, -avg_sumsq, -model_name) %>%
  gather(key, value, -choice_sumsq) %>%
  group_by(key, value) %>%
  summarise(.groups='keep', 
            mean_choice_sumsq = mean(choice_sumsq),
            sem_choice_sumsq = sem(choice_sumsq)) %>%
  ggplot(aes(as.factor(value), mean_choice_sumsq))+
  geom_point()+
  geom_errorbar(aes(ymin = mean_choice_sumsq - sem_choice_sumsq, ymax = mean_choice_sumsq + sem_choice_sumsq), width=.2)+
  facet_wrap(~key)
```
```{r}
summarise_opt_out(m5_opt_out)
```

```{r}
m5_opt_out %>%
  select(-choice_sumsq, -avg_sumsq, -model_name) %>%
  gather(key, value, -rt_sumsq) %>%
  group_by(key, value) %>%
  summarise(.groups='keep', 
            mean_rt_sumsq = mean(rt_sumsq),
            sem_rt_sumsq = sem(rt_sumsq)) %>%
  ggplot(aes(as.factor(value), mean_rt_sumsq))+
  geom_point()+
  geom_errorbar(aes(ymin = mean_rt_sumsq - sem_rt_sumsq, ymax = mean_rt_sumsq + sem_rt_sumsq), width=.2)+
  facet_wrap(~key)
```

# Model 6: 3 integrators + early integration

- Where should nondecision time come into play?

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model6.R'))
sim_trial_list[['model6']] = sim_trial
```

## Check sim task

Need to debug lotteryBias feeding in properly to sim_task depending on the 

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model6", dAttr=0.02, dArb=0.04, sigmaAttr = 0.03, sigmaArb = 0.03, debug = TRUE, lotteryBias = .25)
sim_sanity_checks(tmp)
```

# Trade-offs across models

- Is the relationship between pars that optim rt vs choice the same across models?

No. There can be a trade-off between the parameters depending on what you optimize for but it's not in the same direction for all models.

```{r}
all_opt_outs = list(m1_opt_out, m2_opt_out, m3_opt_out, m4_opt_out, m5_opt_out)
opt_outs_df = data.frame()
for (i in 1:length(all_opt_outs)){
  opt_outs_df = rbind.all.columns(opt_outs_df,
                                  all_opt_outs[[i]]$opt_rt_pars %>%
                                    mutate(model_name = paste0("model", i),
                                           opt_for = "opt_rt") %>%
                                    rbind(all_opt_outs[[i]]$opt_choice_pars %>%
                                            mutate(model_name = paste0("model", i),
                                                   opt_for = "opt_choice")) %>%
                                    rbind(all_opt_outs[[i]]$opt_avg_pars %>%
                                            mutate(model_name = paste0("model", i),
                                                   opt_for = "opt_avg")))
}

opt_outs_df %>%
  select(-barrier_decay, -rt_sumsq, -choice_sumsq, -avg_sumsq) %>%
  gather(par, value, -model_name, -opt_for) %>%
  ggplot(aes(model_name, value, color=opt_for))+
  geom_point(size=4, alpha=.5)+
  facet_wrap(~par)+
  labs(x="", y="", color="")+
  theme(legend.position = "bottom")
```
```{r}
opt_outs_df
```

# Next steps

- Incorporating EV and QV computation instead of using them as input
