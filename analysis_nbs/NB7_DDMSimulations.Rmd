---
title: "Experience vs. description based decision-making project: Adding arbitration to behavioral modeling"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

# Setup

Set up environment and load in data

```{r include=FALSE}
library(tidyverse)
library(gridExtra)
library(brms)
library(here)
library(broom)
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# theme_set(theme_bw())
theme_set(theme_classic())
sem <- function(x) {sd(x, na.rm=T) / sqrt(length(x))}
helpers_path = here('helpers/')

set.seed(38573)
```

Adding in parameters from the two systems model for all subjects (i.e. not choosing the best fitting one per subject)

```{r}
source(paste0(helpers_path,'twoSystemsFitting/fit_twoValSystemsWithRL_hierarchical.R'))
source(paste0(helpers_path,'add_inferred_pars.R'))
clean_beh_data = add_inferred_pars(clean_beh_data, par_ests, model_name="original")
source(paste0(helpers_path,'ddmSims/sim_task.R'))
source(paste0(helpers_path,'ddmSims/sim_sanity_checks.R'))
source(paste0(helpers_path,'ddmSims/find_best_par_combo.R'))
```

# True data

### Motivation for competition

Graph below shows the difference in strength of preference for the left bundle based on EV versus QV. The smaller this difference the harder it should be to make the decision based on one attribute only. 

So if choice is faster when this value is larger that would suggest it is driven primarily by (the relative preference for) one attribute. Alternatively if choice is slower when this value is smaller it suggests integrating

```{r}
clean_beh_data %>%
  mutate(wAbsLeftEVAdv = (1-probFractalDraw)*abs(leftEVAdv), # strength of left preference based on EV
         wAbsLeftQVAdv = (probFractalDraw)*abs(leftQVAdv), # strength of left preference based on QV
         EVAdvMinQVAdv = abs(wAbsLeftEVAdv - wAbsLeftQVAdv), # difference in strength of preference
         probFractalDraw = as.factor(probFractalDraw)) %>%
  group_by(probFractalDraw) %>%
  summarise(meanEVAdvMinQVAdv = mean(EVAdvMinQVAdv),
            semEVAdvMinQVAdv = sem(EVAdvMinQVAdv)) %>%
  ggplot(aes(probFractalDraw, meanEVAdvMinQVAdv))+
  geom_point()+
  geom_errorbar(aes(ymin = meanEVAdvMinQVAdv - semEVAdvMinQVAdv, ymax = meanEVAdvMinQVAdv + semEVAdvMinQVAdv), width=.2)
```

Filter data for a few subjects with a range of learning rates (i.e. variance in QValue differences) to simulate RTs using DDM. Rename columns to work with task simulation function. 

```{r}
sub_data = clean_beh_data %>%
  filter(subnum  %in% c("01", "03", "05","07", "09", "11", "13", "15", "17", "19")) %>%
  select(leftQValue, rightQValue, leftLotteryEV, rightLotteryEV, probFractalDraw, reactionTime, choiceLeft, subnum) %>%
  rename(EVLeft = leftLotteryEV, EVRight = rightLotteryEV, QVLeft = leftQValue, QVRight = rightQValue)
```

## Sanity checks in the sampled data

```{r}
sim_sanity_checks(sub_data %>%
                    select(-subnum) %>%
                    mutate(choice = ifelse(choiceLeft == 1, "left", "right")), 
                  compare_rts = FALSE)
```

# Optimization prep

Create empty list that will store the trial simulators for the forthcoming models.

```{r}
sim_trial_list = list()
```

Define parameter space in which you'll search for best fits for the following models.

```{r}
d_par_space = c(.002, .004, .006, .008 ,.01, .02, .04, .06, .08, .1)
sigma_par_space = c(.004, .008 ,.01, .02, .04, .06, .08, .1)
```

# Model 1: Simplest

- Integration begins at stim presentation for all conditions
- Drift rate is proportional to the bundle value difference 
- Bundle values are computed as sums of QV and EV weighted by their relevance (no distortion of probability)

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model1.R'))
sim_trial_list[['model1']] = sim_trial
```

## Check sim task 

```{r eval = FALSE, echo = FALSE}
tmp = sim_task(sub_data, model_name="model1", d=0.04, sigma = 0.02)
sim_sanity_checks(tmp)
```
### What controls spread vs mean?

```{r}
tmp1 = sim_task(sub_data, model_name = "model1", d=0.06, sigma = 0.03)
sim_sanity_checks(tmp1, checks=c(3))
```

```{r}
tmp2 = sim_task(sub_data, model_name = "model1", d=0.06, sigma = 0.003)
sim_sanity_checks(tmp2, checks=c(3))
```

```{r}
tmp3 = sim_task(sub_data, model_name = "model1", d=0.006, sigma = 0.03)
sim_sanity_checks(tmp3, checks=c(3))
```

```{r}
tmp4 = sim_task(sub_data, model_name = "model1", d=0.006, sigma = 0.003)
sim_sanity_checks(tmp4, checks=c(3))
```

```{r}
rm(tmp1, tmp2, tmp3, tmp4)
```

## Opt pars

```{r}
m1_opt_out = find_best_par_combo(sub_data, model_name = "model1", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
sim_data_m1 = sim_w_best_combo(m1_opt_out, "model1")
```

```{r}
sim_sanity_checks(sim_data_m1$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m1$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m1$sim_data_opt_choice)
}
```

# Model 2: Early integration

- For probFractalDraw == 1 trials begin integrating before stimulus presentation proportional to QV difference weighted by drift rate
- Once early integration is complete integration uses both QV and EV differences weighted by relevance

```{r}
sim_trial = function(d, sigma, barrierDecay, barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=400, epsilon = 0.0002, stimDelay = 2000, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  if (debug){
    debug_df = data.frame()
  }
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  decPreStim = 0
  timeOut = 0
  
  kwargs = list(...)
  
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  # Stimulus screen comes on 2 secs after the presentation of probFractalDraw
  stimDelayIters = stimDelay / timeStep
  nonDecIters = nonDecisionTime / timeStep

  # Integration starts before stim presentation (though meaningful move from 0 happens only for pFrac = 1 trials) but decision can only be indicated after stim. Since total iterations depend on maxIter the addition of iterations before stim presentation controls for the desired max time out for the trial. In the arguments to the function it is specified as the maximum time out duration after stim presentation
  maxIter = maxIter + stimDelayIters

  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  # Barrier decay starts after stim presentation. Not during any possible sampling before that
  for(t in seq(stimDelayIters, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * (t-stimDelayIters))
  }
  
  qv_mu_mean = d*(QVLeft - QVRight)

  leftFractalAdv =  probFractalDraw* (QVLeft - QVRight)
  leftLotteryAdv = (1-probFractalDraw) * (EVLeft - EVRight)
  weighted_mu_mean = d * (leftFractalAdv + leftLotteryAdv)
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier[time] | RDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      # Debugging
      if(debug){
        print(paste0("pre subtraction RT = ", RT))
      }
      
      #subtract stimDelay
      RT = RT - (stimDelay/1000) 
      
      # If decision is reached before the stim screen sample rt from log normal distribution similar to choice RT 
      if (RT < 0){
        decPreStim = 1
        RT=rlnorm(1, mean = -.25, sd = 0.5)
      }
      
      if (RDV >= barrier[time]){
        choice = "left"
      } else if (RDV <= -barrier[time]){
        choice = "right"
      }
      break
    } 
    
    if (time < stimDelayIters){
      if (probFractalDraw == 1){
        mu_mean = qv_mu_mean
      } else {
        # No integration before stim presentation for any other trial type
        mu_mean = 0
      }
    } else{
      if (elapsedNDT < nonDecIters){
        mu_mean = 0
        elapsedNDT = elapsedNDT + 1
      } else{
        mu_mean = weighted_mu_mean
      }
    }
    
    
    
    # Sample the change in RDV from the distribution.
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    if (debug){
      debug_row = data.frame(time = time, mu_mean = mu_mean, mu = round(mu, 3), RDV = round(RDV, 3), barrier = round(barrier[time], 3))
      debug_df = rbind.all.columns(debug_df, debug_row)
      }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    if (RDV >= 0){
      choice = "left"
    } else if (RDV <= 0){
      choice = "right"
    }
    if(debug){
      print("Max iterations reached.")
    }
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, decPreStim = decPreStim, leftFractalAdv = leftFractalAdv, leftLotteryAdv = leftLotteryAdv, d = d, sigma = sigma, barrierDecay = barrierDecay)
  
  if(debug){
    return(list(out=out, debug_df = debug_df[-1,]))
  } else {
    return(out)
  }
}
sim_trial_list[['model2']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model2", d=0.04, sigma = 0.03)
sim_sanity_checks(tmp)
```

When does integration reach a bound before the stim presentation?

```{r}
with(tmp, table(decPreStim, probFractalDraw))
```

```{r}
tmp %>%
  select(EVLeft, EVRight, QVLeft, QVRight, probFractalDraw, choice, reactionTime, decPreStim) %>%
  mutate(data_type = "sim") %>%
  rbind(sub_data %>%
          mutate(choice = ifelse(choiceLeft == 1, "left", "right"),
                 data_type = "true",
                 decPreStim = "trueData") %>%
          select(-subnum, -choiceLeft)) %>%
  mutate(probFractalDraw = as.factor(probFractalDraw)) %>%
  ggplot(aes(reactionTime, fill=decPreStim)) +
  geom_histogram(position="identity", bins=30, alpha=.5) +
  facet_wrap(~probFractalDraw)+
  theme(legend.position = "bottom")
```

## Opt pars

```{r}
m2_opt_out = find_best_par_combo(sub_data, model_name = "model2", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
sim_data_m2 = sim_w_best_combo(m2_opt_out, "model2")
```

```{r}
sim_sanity_checks(sim_data_m2$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m2$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m2$sim_data_opt_choice)
}
```

What is going on with the trials that hit decision before stimuli are presented but are not pfrac = 1? There should be no integration for these before the stimuli are presented. Seems to go down quickly with reducing sigma so they're likely from noise integration but reducing sigma messes up other things as well

```{r eval=FALSE, echo=FALSE}
sim_data_m2_opt_rt %>% 
  filter(decPreStim == 1)
```

# Model 3: Model 2 + relative preference weighting

```{r}
sim_trial = function(d, sigma, barrierDecay, barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=400, epsilon = 0.0002, stimDelay = 2000, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  if(debug){
    debug_df = data.frame()
  }
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  decPreStim = 0
  timeOut = 0
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  # Stimulus screen comes on 2 secs after the presentation of probFractalDraw
  stimDelayIters = stimDelay / timeStep
  nonDecIters = nonDecisionTime / timeStep

  # Integration starts before stim presentation (though meaningful move from 0 happens only for pFrac = 1 trials) but decision can only be indicated after stim. Since total iterations depend on maxIter the addition of iterations before stim presentation controls for the desired max time out for the trial. In the arguments to the function it is specified as the maximum time out duration after stim presentation
  maxIter = maxIter + stimDelayIters
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  # Barrier decay starts after stim presentation. Not during any possible sampling before that
  for(t in seq(stimDelayIters, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * (t-stimDelayIters))
  }
  
  qv_mu_mean = d*(QVLeft - QVRight)
  leftFractalAdv =  probFractalDraw* (QVLeft - QVRight)
  leftLotteryAdv = (1-probFractalDraw) * (EVLeft - EVRight)
  relPrefFractal = abs(leftFractalAdv)/(abs(leftLotteryAdv)+abs(leftFractalAdv)+1e-6)
  weighted_mu_mean = d * (relPrefFractal * leftFractalAdv + (1-relPrefFractal) * leftLotteryAdv)

  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier[time] | RDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      #subtract stimDelay
      RT = RT - (stimDelay/1000) 
      
      # If decision is reached before the stim screen sample rt from log normal distribution similar to choice RT 
      if (RT < 0){
        decPreStim = 1
        RT=rlnorm(1, mean = -.25, sd = 0.5)
      }
      
      if (RDV >= barrier[time]){
        choice = "left"
      } else if (RDV <= -barrier[time]){
        choice = "right"
      }
      break
    } 
    
    if (time < stimDelayIters){
      # Integration after fractal prob presentation but before stim presentation happens ONLY for the probfractaldraw == 1 trials
      if (probFractalDraw == 1){
        mu_mean = qv_mu_mean
      } else {
        # No integration before stim presentation for any other trial type
        mu_mean = 0
      }
    } else{
      if (elapsedNDT < nonDecIters){
        mu_mean = 0
        elapsedNDT = elapsedNDT + 1
      } else{
        mu_mean = weighted_mu_mean
      }
    }
    
    # Sample the change in RDV from the distribution.
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    if (debug){
      debug_row = data.frame(time = time, mu_mean = mu_mean, mu = round(mu, 3), RDV = round(RDV, 3), barrier = round(barrier[time], 3))
      debug_df = rbind.all.columns(debug_df, debug_row)
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    if (RDV >= 0){
      choice = "left"
    } else if (RDV <= 0){
      choice = "right"
    }
    if(debug){
      print("Max iterations reached.")
    }
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, decPreStim = decPreStim, leftFractalAdv = leftFractalAdv, leftLotteryAdv = leftLotteryAdv,  relPrefFractal = relPrefFractal, d = d, sigma = sigma, barrierDecay = barrierDecay, barrier = barrier[time], RDV = RDV)
  
  if(debug){
    return(list(out=out, debug_df=debug_df))
  }else{
    return(out)
  }
  
}
sim_trial_list[['model3']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model3", d=0.05, sigma = 0.01)
sim_sanity_checks(tmp)
```

## Opt pars

```{r}
m3_opt_out = find_best_par_combo(sub_data, model_name = "model3", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
sim_data_m3 = sim_w_best_combo(m3_opt_out, "model3")
```

```{r}
sim_sanity_checks(sim_data_m3$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m3$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m3$sim_data_opt_choice)
}

```

# Model 4: 3 integrators

- all biases are by moving the starting points
  - for all trials there is a general lottery bias
  - for pfrac == 1 trials there is a fractal bias the size of the QV difference
- Integration happens for EV and QV separately along with an arbitrator that determines the decision

```{r}
sim_trial = function(dArb, dAttr, sigmaArb, sigmaAttr, barrierDecay, barrier=1, nonDecisionTime=0, lotteryBias=0.1, timeStep=10, maxIter=400, epsilon = 0.002, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  
  arbitratorRDV = lotteryBias
  fractalRDV = 0
  lotteryRDV = 0
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  timeOut = 0
  
  arbitrator_mu_mean = NA
  if(debug){
    debug_df = data.frame()
  }
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  
  # pFrac == 1 bias
  probFractalDraw=kwargs$probFractalDraw
  if(probFractalDraw == 1){
    fractalRDV = QVLeft - QVRight
  }
  
  nonDecIters = nonDecisionTime / timeStep
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  for(t in seq(1, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * t)
  }
  
  lottery_mu_mean = dAttr * (1-probFractalDraw) * (EVLeft - EVRight)
  fractal_mu_mean = dAttr * probFractalDraw * (QVLeft - QVRight)
  
  while (time<maxIter){
    
    # If the arbitrator RDV hits one of the barriers make decision
    if (arbitratorRDV >= barrier[time] | arbitratorRDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      if (arbitratorRDV >= barrier[time]){
        arbitrator = "EV"
        choice = ifelse(lotteryRDV > 0, "left", "right")
      } else if (arbitratorRDV <= -barrier[time]){
        arbitrator = "QV"
        choice = ifelse(fractalRDV > 0, "left", "right")
      }
      break
    } 
    
    # Otherwise continue sampling evidence
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      
      # Three integrators
      
      # Lottery integrator
      lottery_mu = rnorm(1, lottery_mu_mean, epsilon)
      lotteryRDV = lotteryRDV + rnorm(1, lottery_mu, sigmaAttr)
      
      # Fractal integrator
      fractal_mu = rnorm(1, fractal_mu_mean, epsilon)
      fractalRDV = fractalRDV + rnorm(1, fractal_mu, sigmaAttr)
      
      # Arbitrator 
      # If abs(lotteryRDV) > abs(fractalRDV) stronger relative preference for a side based on lotteries
      arbitrator_mu_mean = dArb * (abs(lotteryRDV) - abs(fractalRDV))
      arbitrator_mu = rnorm(1, arbitrator_mu_mean, epsilon)
      arbitratorRDV = arbitratorRDV + rnorm(1, arbitrator_mu, sigmaArb)
    }
    
    if (debug){
      debug_row = data.frame(time = time, arbitrator_mu_mean = round(arbitrator_mu_mean, 3), arbitratorRDV = round(arbitratorRDV, 3), barrier = round(barrier[time], 3), lotteryRDV = round(lotteryRDV, 3), fractalRDV = round(fractalRDV, 3))
      debug_df = rbind(debug_df, debug_row)
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    arbitrator = ifelse(arbitratorRDV >= 0 , "EV", "QV")
    if(arbitrator == "EV"){
      choice = ifelse(lotteryRDV > 0, "left", "right")
    } else if (arbitrator == "QV"){
      choice = ifelse(fractalRDV > 0, "left", "right")
    }
   
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, arbitrator = arbitrator)
  
  if(debug){
    out = list(out=out, debug_df=debug_df[-1,])
  }
  
  return(out)
}
sim_trial_list[['model4']] = sim_trial
```

Example visualization of integration

```{r echo=FALSE, eval=FALSE}
tmp = sim_trial(d = .033, sigma = .03, barrierDecay = 0.005, EVLeft = .7, EVRight = 0.5, QVLeft = 0.3, QVRight = 0.7, probFractalDraw = .8, debug=TRUE, nonDecisionTime = 0)

tmp$debug_df %>%
  select(-arbitrator_mu_mean) %>%
  gather(key, value, -time, -barrier) %>%
  ggplot()+
  geom_line(aes(time, value))+
  geom_line(aes(time, barrier), color="red")+
  geom_line(aes(time, -barrier), color="green")+
  geom_hline(aes(yintercept = 0), linetype="dashed")+
  facet_grid(key ~.)
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model4", dAttr=0.04, dArb=0.04, sigmaAttr = 0.03, sigmaArb = 0.03)
sim_sanity_checks(tmp)
```

## Opt pars

```{r}
m4_opt_out = find_best_par_combo(sub_data, model_name = "model4", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
summarise_opt_out(m4_opt_out)
```

```{r}
m4_opt_out %>%
  select(rt_sumsq, choice_sumsq) %>%
  gather(key, value) %>%
  ggplot(aes(value, fill=key)) +
  geom_histogram(position="identity", alpha=.5, bins=30) +
  theme(legend.position = "bottom")+
  labs(fill="")
```

```{r}
sim_data_m4 = sim_w_best_combo(m4_opt_out, "model4")
```

```{r}
sim_sanity_checks(sim_data_m4$sim_data_opt_rt)
```

```{r}
if(is.na(sim_data_m4$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m4$sim_data_opt_choice)
}

```

# Model 5: 3 integrators

- Same as model 4 but with attribute relevance affecting arbitrator and not the attribute integrators

```{r}
sim_trial = function(dArb, dAttr, sigmaArb, sigmaAttr, barrierDecay, barrier=1, nonDecisionTime=0, lotteryBias=0.1, timeStep=10, maxIter=400, epsilon = 0.002, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  
  arbitratorRDV = lotteryBias
  lotteryRDV = 0
  fractalRDV = 0
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  timeOut = 0
  
  arbitrator_mu_mean = NA
  if(debug){
    debug_df = data.frame()
  }
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
 
  # pFrac == 1 bias
  probFractalDraw=kwargs$probFractalDraw
  if(probFractalDraw == 1){
    fractalRDV = QVLeft - QVRight
  }
  
  nonDecIters = nonDecisionTime / timeStep
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  for(t in seq(1, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * t)
  }
  
  lottery_mu_mean = dAttr * (EVLeft - EVRight)
  fractal_mu_mean = dAttr * (QVLeft - QVRight)
  
  while (time<maxIter){
    
    # If the arbitrator RDV hits one of the barriers make decision
    if (arbitratorRDV >= barrier[time] | arbitratorRDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      if (arbitratorRDV >= barrier[time]){
        arbitrator = "EV"
        choice = ifelse(lotteryRDV > 0, "left", "right")
      } else if (arbitratorRDV <= -barrier[time]){
        arbitrator = "QV"
        choice = ifelse(fractalRDV > 0, "left", "right")
      }
      break
    } 
    
    # Otherwise continue sampling evidence
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      
      # Three integrators
      
      # Lottery integrator
      lottery_mu = rnorm(1, lottery_mu_mean, epsilon)
      lotteryRDV = lotteryRDV + rnorm(1, lottery_mu, sigmaAttr)
      
      # Fractal integrator
      fractal_mu = rnorm(1, fractal_mu_mean, epsilon)
      fractalRDV = fractalRDV + rnorm(1, fractal_mu, sigmaAttr)
      
      # Arbitrator 
      # If abs(lotteryRDV) > abs(fractalRDV) stronger relative preference for a side based on lotteries
      arbitrator_mu_mean = dArb * ((1-probFractalDraw) * abs(lotteryRDV) - (probFractalDraw) * abs(fractalRDV))
      arbitrator_mu = rnorm(1, arbitrator_mu_mean, epsilon)
      arbitratorRDV = arbitratorRDV + rnorm(1, arbitrator_mu, sigmaArb)
    }
    
    if (debug){
      debug_row = data.frame(time = time, arbitrator_mu_mean = round(arbitrator_mu_mean, 3), arbitratorRDV = round(arbitratorRDV, 3), barrier = round(barrier[time], 3), lotteryRDV = round(lotteryRDV, 3), fractalRDV = round(fractalRDV, 3))
      debug_df = rbind(debug_df, debug_row)
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    arbitrator = ifelse(arbitratorRDV >= 0 , "EV", "QV")
    if(arbitrator == "EV"){
      choice = ifelse(lotteryRDV > 0, "left", "right")
    } else if (arbitrator == "QV"){
      choice = ifelse(fractalRDV > 0, "left", "right")
    }
   
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, arbitrator = arbitrator)
  
  if(debug){
    out = list(out=out, debug_df=debug_df)
  }
  
  return(out)
}
sim_trial_list[['model5']] = sim_trial
```

Example visualization of integration

```{r echo=FALSE, eval=FALSE}
tmp = sim_trial(dArb = .04, dAttr=0.1, sigmaArb = .02, sigmaAttr = .01, barrierDecay = 0, EVLeft = .7, EVRight = 0.5, QVLeft = 0, QVRight = 0, probFractalDraw = .8, debug=TRUE, nonDecisionTime = 0)

tmp$debug_df %>%
  select(-arbitrator_mu_mean) %>%
  gather(key, value, -time, -barrier) %>%
  ggplot()+
  geom_line(aes(time, value))+
  geom_line(aes(time, barrier), color="red")+
  geom_line(aes(time, -barrier), color="green")+
  geom_hline(aes(yintercept = 0), linetype="dashed")+
  facet_grid(key ~.)+
  theme_bw()
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model5", dAttr=0.04, dArb=0.04, sigmaAttr = 0.03, sigmaArb = 0.03)
sim_sanity_checks(tmp)
```

```{r}
tmp %>%
  select(EVLeft, EVRight, QVLeft, QVRight, probFractalDraw, choice, reactionTime, arbitrator) %>%
  mutate(data_type = "sim") %>%
  rbind(sub_data %>%
          mutate(choice = ifelse(choiceLeft == 1, "left", "right"),
                 data_type = "true",
                 arbitrator= "true") %>%
          select(-subnum, -choiceLeft)) %>%
  mutate(probFractalDraw = as.factor(probFractalDraw)) %>%
  ggplot(aes(reactionTime, fill=as.factor(arbitrator))) +
  geom_histogram(position="identity", bins=30, alpha=.5) +
  labs(title="RT long tail?", fill="")+
  facet_wrap(~probFractalDraw)+
  theme(legend.position = "bottom")
```

## Opt pars

```{r}
m5_opt_out = find_best_par_combo(sub_data, model_name = "model5", 
                                 d_par_space = d_par_space, 
                                 sigma_par_space = sigma_par_space)
```

```{r}
summarise_opt_out(m5_opt_out)
```

```{r}
sim_data_m5 = sim_w_best_combo(m5_opt_out, "model5")
```

```{r}
sim_sanity_checks(sim_data_m5$sim_data_opt_rt)
```

```{r}
summarise_opt_out(m5_opt_out)
```

```{r}
if(is.na(sim_data_m5$sim_data_opt_choice)){
  print("Same data as above.")
} else {
  sim_sanity_checks(sim_data_m5$sim_data_opt_choice)
}

```

How to visualize goodness of fit across

```{r}
m5_opt_out %>% 
  select(rt_sumsq, choice_sumsq) %>%
  mutate(choice_sumsq = ifelse(choice_sumsq>500, 500, choice_sumsq)) %>%
  gather(key, value) %>%
  ggplot(aes(value))+
  geom_histogram(position="identity", alpha = .5, bins=30) +
  facet_wrap(~key, scales="free")
```

```{r}
m5_opt_out %>%
  mutate(choice_sumsq = ifelse(choice_sumsq>500, 500, choice_sumsq)) %>%
  select(-rt_sumsq, -avg_sumsq, -model_name) %>%
  gather(key, value, -choice_sumsq) %>%
  group_by(key, value) %>%
  summarise(.groups='keep', 
            mean_choice_sumsq = mean(choice_sumsq),
            sem_choice_sumsq = sem(choice_sumsq)) %>%
  ggplot(aes(as.factor(value), mean_choice_sumsq))+
  geom_point()+
  geom_errorbar(aes(ymin = mean_choice_sumsq - sem_choice_sumsq, ymax = mean_choice_sumsq + sem_choice_sumsq), width=.2)+
  facet_wrap(~key)
```
```{r}
summarise_opt_out(m5_opt_out)
```

```{r}
m5_opt_out %>%
  select(-choice_sumsq, -avg_sumsq, -model_name) %>%
  gather(key, value, -rt_sumsq) %>%
  group_by(key, value) %>%
  summarise(.groups='keep', 
            mean_rt_sumsq = mean(rt_sumsq),
            sem_rt_sumsq = sem(rt_sumsq)) %>%
  ggplot(aes(as.factor(value), mean_rt_sumsq))+
  geom_point()+
  geom_errorbar(aes(ymin = mean_rt_sumsq - sem_rt_sumsq, ymax = mean_rt_sumsq + sem_rt_sumsq), width=.2)+
  facet_wrap(~key)
```

# Model 6: 3 integrators + early integration

- Where should nondecision time come into play?

```{r}
sim_trial = function(dArb, dAttr, sigmaArb, sigmaAttr, barrierDecay, barrier=1, nonDecisionTime=0, lotteryBias=0.01, timeStep=10, maxIter=400, epsilon = 0.002, stimDelay = 2000, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  
  # arbitratorRDV = lotteryBias
  arbitratorRDV = 0
  fractalRDV = 0
  lotteryRDV = 0
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  decPreStim = 0
  timeOut = 0
  
  arbitrator_mu_mean = NA
  if(debug){
    debug_df = data.frame()
  }
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  
  # remove bias from arbitrator RDV if pFrac == 1
  probFractalDraw=kwargs$probFractalDraw
  if(probFractalDraw == 1){
    arbitratorRDV = 0
  }
  
  nonDecIters = nonDecisionTime / timeStep
  stimDelayIters = stimDelay / timeStep
  maxIter = maxIter + stimDelayIters
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  for(t in seq(1, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * t)
  }
  
  lottery_mu_mean = dAttr * (1+lotteryBias) * (EVLeft - EVRight) * (1-probFractalDraw)
  fractal_mu_mean = dAttr * (QVLeft - QVRight) * (probFractalDraw)
  
  while (time<maxIter){
    
    # If the arbitrator RDV hits one of the barriers make decision
    if (arbitratorRDV >= barrier[time] | arbitratorRDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      #subtract stimDelay
      RT = RT - (stimDelay/1000) 
      
      # If decision is reached before the stim screen sample rt from log normal distribution similar to choice RT 
      if (RT < 0){
        decPreStim = 1
        RT=rlnorm(1, mean = -.25, sd = 0.5)
      }
      
      if (arbitratorRDV >= barrier[time]){
        arbitrator = "EV"
        choice = ifelse(lotteryRDV > 0, "left", "right")
      } else if (arbitratorRDV <= -barrier[time]){
        arbitrator = "QV"
        choice = ifelse(fractalRDV > 0, "left", "right")
      }
      break
    } 
    
    # Start early integration when fractals are the more relevant attribute
    if(time < stimDelayIters){
      
      if(probFractalDraw == 1){
        fractal_mu = rnorm(1, fractal_mu_mean, epsilon)
        fractalRDV = fractalRDV + rnorm(1, fractal_mu, sigmaAttr)
        
        arbitrator_mu_mean = dArb * (-1) * ((probFractalDraw) * abs(fractalRDV))
      } else {
        arbitrator_mu_mean = 0
      }
      arbitrator_mu = rnorm(1, arbitrator_mu_mean, epsilon)
      arbitratorRDV = arbitratorRDV + rnorm(1, arbitrator_mu, sigmaArb)
    
    # Integration after stim presentation  
    } else{
      if (elapsedNDT < nonDecIters){
        mu_mean = 0
        elapsedNDT = elapsedNDT + 1
      } else{
        
        # Lottery integrator
        lottery_mu = rnorm(1, lottery_mu_mean, epsilon)
        lotteryRDV = lotteryRDV + rnorm(1, lottery_mu, sigmaAttr)
        
        # Fractal integrator
        fractal_mu = rnorm(1, fractal_mu_mean, epsilon)
        fractalRDV = fractalRDV + rnorm(1, fractal_mu, sigmaAttr)
        
        # Arbitrator 
        # If abs(lotteryRDV) > abs(fractalRDV) stronger relative preference for a side based on lotteries
        arbitrator_mu_mean = dArb * ((1-probFractalDraw) * abs(lotteryRDV) - (probFractalDraw) * abs(fractalRDV))
        arbitrator_mu = rnorm(1, arbitrator_mu_mean, epsilon)
        arbitratorRDV = arbitratorRDV + rnorm(1, arbitrator_mu, sigmaArb)
      }
    }
    
    if (debug){
      debug_row = data.frame(time = time, arbitrator_mu_mean = round(arbitrator_mu_mean, 3), arbitratorRDV = round(arbitratorRDV, 3), barrier = round(barrier[time], 3), lotteryRDV = round(lotteryRDV, 3), fractalRDV = round(fractalRDV, 3))
      debug_df = rbind(debug_df, debug_row)
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    arbitrator = ifelse(arbitratorRDV >= 0 , "EV", "QV")
    if(arbitrator == "EV"){
      choice = ifelse(lotteryRDV > 0, "left", "right")
    } else if (arbitrator == "QV"){
      choice = ifelse(fractalRDV > 0, "left", "right")
    }
   
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, arbitrator = arbitrator, decPreStim = decPreStim)
  
  if(debug){
    out = list(out=out, debug_df=debug_df)
  }
  
  return(out)
}
sim_trial_list[['model6']] = sim_trial
```

## Check sim task

Need to debug lotteryBias feeding in properly to sim_task depending on the 

```{r eval=FALSE, echo=FALSE}
tmp = sim_task(sub_data, model_name = "model6", dAttr=0.02, dArb=0.04, sigmaAttr = 0.03, sigmaArb = 0.03, debug = TRUE, lotteryBias = .25)
sim_sanity_checks(tmp)
```

# Trade-offs across models

- Is the relationship between pars that optim rt vs choice the same across models?

No. There can be a trade-off between the parameters depending on what you optimize for but it's not in the same direction for all models.

```{r}
all_opt_outs = list(m1_opt_out, m2_opt_out, m3_opt_out, m4_opt_out, m5_opt_out)
opt_outs_df = data.frame()
for (i in 1:length(all_opt_outs)){
  opt_outs_df = rbind.all.columns(opt_outs_df,
                                  all_opt_outs[[i]]$opt_rt_pars %>%
                                    mutate(model_name = paste0("model", i),
                                           opt_for = "opt_rt") %>%
                                    rbind(all_opt_outs[[i]]$opt_choice_pars %>%
                                            mutate(model_name = paste0("model", i),
                                                   opt_for = "opt_choice")) %>%
                                    rbind(all_opt_outs[[i]]$opt_avg_pars %>%
                                            mutate(model_name = paste0("model", i),
                                                   opt_for = "opt_avg")))
}

opt_outs_df %>%
  select(-barrier_decay, -rt_sumsq, -choice_sumsq, -avg_sumsq) %>%
  gather(par, value, -model_name, -opt_for) %>%
  ggplot(aes(model_name, value, color=opt_for))+
  geom_point(size=4, alpha=.5)+
  facet_wrap(~par)+
  labs(x="", y="", color="")+
  theme(legend.position = "bottom")
```
```{r}
opt_outs_df
```

# Next steps

- Incorporating EV and QV computation instead of using them as input
