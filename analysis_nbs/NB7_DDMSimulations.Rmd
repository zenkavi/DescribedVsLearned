---
title: "Experience vs. description based decision-making project: Adding arbitration to behavioral modeling"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

# Setup

Set up environment and load in data

```{r include=FALSE}
library(tidyverse)
library(gridExtra)
library(brms)
library(here)
library(broom)
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
theme_set(theme_classic())
sem <- function(x) {sd(x, na.rm=T) / sqrt(length(x))}
helpers_path = here('helpers/')

set.seed(38573)
```

Adding in parameters from the two systems model for all subjects (i.e. not choosing the best fitting one per subject)

```{r}
source(paste0(helpers_path,'twoSystemsFitting/fit_twoValSystemsWithRL_hierarchical.R'))
source(paste0(helpers_path,'add_inferred_pars.R'))
clean_beh_data = add_inferred_pars(clean_beh_data, par_ests, model_name="original")
source(paste0(helpers_path,'ddmSims/sim_task.R'))
source(paste0(helpers_path,'ddmSims/sim_sanity_checks.R'))
source(paste0(helpers_path,'ddmSims/find_best_par_combo.R'))
```

# True data

### Motivation for competition

Graph below shows the difference in strength of preference for the left bundle based on EV versus QV. The smaller this difference the harder it should be to make the decision based on one attribute only. 

So if choice is faster when this value is larger that would suggest it is driven primarily by (the relative preference for) one attribute. Alternatively if choice is slower when this value is smaller it suggests integrating

```{r}
clean_beh_data %>%
  mutate(wAbsLeftEVAdv = (1-probFractalDraw)*abs(leftEVAdv), # strength of left preference based on EV
         wAbsLeftQVAdv = (probFractalDraw)*abs(leftQVAdv), # strength of left preference based on QV
         EVAdvMinQVAdv = abs(wAbsLeftEVAdv - wAbsLeftQVAdv), # difference in strength of preference
         probFractalDraw = as.factor(probFractalDraw)) %>%
  group_by(probFractalDraw) %>%
  summarise(meanEVAdvMinQVAdv = mean(EVAdvMinQVAdv),
            semEVAdvMinQVAdv = sem(EVAdvMinQVAdv)) %>%
  ggplot(aes(probFractalDraw, meanEVAdvMinQVAdv))+
  geom_point()+
  geom_errorbar(aes(ymin = meanEVAdvMinQVAdv - semEVAdvMinQVAdv, ymax = meanEVAdvMinQVAdv + semEVAdvMinQVAdv), width=.2)
```

Filter data for a few subjects with a range of learning rates (i.e. variance in QValue differences) to simulate RTs using DDM. Rename columns to work with task simulation function. 

```{r}
sub_data = clean_beh_data %>%
  filter(subnum  %in% c("01", "03", "05","07", "09", "11", "13", "15", "17", "19")) %>%
  select(leftQValue, rightQValue, leftLotteryEV, rightLotteryEV, probFractalDraw, reactionTime, choiceLeft, subnum) %>%
  rename(EVLeft = leftLotteryEV, EVRight = rightLotteryEV, QVLeft = leftQValue, QVRight = rightQValue)
```

## Sanity checks in the sampled data

```{r}
sim_sanity_checks(sub_data %>%
                    select(-subnum) %>%
                    mutate(choice = ifelse(choiceLeft == 1, "left", "right")), 
                  compare_rts = FALSE)
```

Individual subject plots for the above stylized RT and choice plots

```{r}
sub_data %>%
  # select(-subnum) %>%
  mutate(choice = ifelse(choiceLeft == 1, "left", "right"))%>%
  drop_na()%>%
  mutate(probFractalDraw = as.factor(probFractalDraw), 
         log_rt = log(reactionTime)) %>%
  group_by(probFractalDraw, subnum) %>%
  summarise(mean_log_rt = mean(log_rt),
            sem_log_rt = sem(log_rt), .groups="keep") %>%
  ggplot(aes(probFractalDraw, mean_log_rt))+
  geom_point()+
  geom_errorbar(aes(ymin = mean_log_rt - sem_log_rt, ymax = mean_log_rt + sem_log_rt), width=.2)+
  facet_wrap(~subnum, scales = 'free')
```

```{r}
sub_data %>%
  mutate(choice = ifelse(choiceLeft == 1, "left", "right"))%>%
  select(EVLeft, EVRight, QVLeft, QVRight, probFractalDraw, choice, reactionTime, subnum) %>%
  mutate(probFractalDraw = as.factor(probFractalDraw),
         choiceLeft = ifelse(choice == "left", 1, ifelse(choice=="right", 0, NA)),
         EVDiff = EVLeft - EVRight, 
         QVDiff = QVLeft - QVRight) %>%
  nest(data = -probFractalDraw, -subnum) %>% 
  mutate(
    fit = map(data, ~ glm(choiceLeft ~ scale(EVDiff) + scale(QVDiff), data = .x, family=binomial(link="logit"))),
    tidied = map(fit, tidy)
  ) %>% 
  unnest(tidied) %>%
  filter(term != "(Intercept)") %>%
  select(subnum, probFractalDraw, term, estimate, std.error) %>%
  ggplot(aes(probFractalDraw, estimate, col=term, group=term))+
  geom_point()+
  geom_line()+
  geom_errorbar(aes(ymin = estimate - std.error, ymax = estimate +std.error), width=0.2)+
  geom_hline(aes(yintercept=0), linetype="dashed")+
  scale_color_manual(values = cbbPalette[2:1])+
  theme(legend.position = "bottom")+
  labs(color="", title="Relevant attribute effect on choice")+
  facet_wrap(~subnum, scales="free")+
  ylim(-2.5, 10)
```

Create empty list that will store the trial simulators for the forthcoming models.

```{r}
sim_trial_list = list()
```

# Model 1: Simplest

- Integration begins at stim presentation for all conditions
- Drift rate is proportional to the bundle value difference 
- Bundle values are computed as sums of QV and EV weighted by their relevance (no distortion of probability)

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model1.R'))
sim_trial_list[['model1']] = sim_trial
```

## Check sim task 

```{r}
m1 = sim_task(sub_data, model_name="model1", d=0.04, sigma = 0.02)
```

```{r}
sim_sanity_checks(m1)
```

### What controls spread vs mean?

```{r}
tmp1 = sim_task(sub_data, model_name = "model1", d=0.06, sigma = 0.03)
sim_sanity_checks(tmp1, checks=c(3))
```

```{r}
tmp2 = sim_task(sub_data, model_name = "model1", d=0.06, sigma = 0.003)
sim_sanity_checks(tmp2, checks=c(3))
```

```{r}
tmp3 = sim_task(sub_data, model_name = "model1", d=0.006, sigma = 0.03)
sim_sanity_checks(tmp3, checks=c(3))
```

```{r}
tmp4 = sim_task(sub_data, model_name = "model1", d=0.006, sigma = 0.003)
sim_sanity_checks(tmp4, checks=c(3))
```

```{r}
rm(tmp1, tmp2, tmp3, tmp4)
```

# Model 2: Early integration

- Early integrator for pFractalDraw == 1 only.

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model2.R'))
sim_trial_list[['model2']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
m2 = sim_task(sub_data, model_name = "model2", d=0.05, sigma = 0.02)
sim_sanity_checks(m2)
```

When does integration reach a bound before the stim presentation?

```{r}
with(m2, table(decPreStim, probFractalDraw))
```

```{r}
m2 %>%
  select(EVLeft, EVRight, QVLeft, QVRight, probFractalDraw, choice, reactionTime, decPreStim) %>%
  mutate(data_type = "sim") %>%
  rbind(sub_data %>%
          mutate(choice = ifelse(choiceLeft == 1, "left", "right"),
                 data_type = "true",
                 decPreStim = "trueData") %>%
          select(-subnum, -choiceLeft)) %>%
  mutate(probFractalDraw = as.factor(probFractalDraw)) %>%
  ggplot(aes(reactionTime, fill=decPreStim)) +
  geom_histogram(position="identity", bins=30, alpha=.5) +
  facet_wrap(~probFractalDraw)+
  theme(legend.position = "bottom")
```

```{r}
with(m2, table(timeOut, probFractalDraw))
```

# Model 2a

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model2a.R'))
sim_trial_list[['model2a']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
m2a = sim_task(sub_data, model_name = "model2a", d=0.05, sigma = 0.02, theta = 0.1)
sim_sanity_checks(m2a, yrange_lim = 30)
```

# Model 2b: Asymmetric prob distortion

- Distort probFractalDraw when integrating info about fractals but no distortion for lotteries
- Intended to capture the stepwise nature of the logit slopes for the QV difference but the linear nature for the EV difference

```{r}
data.frame(pFrac = seq(0, 1, .1),
           delta = 1, gamma = 1) %>%
  mutate(distortedPFrac = exp( (-1) * delta * ((-1)*log(pFrac))^gamma) ) %>%
  ggplot(aes(pFrac, distortedPFrac))+
  geom_point()+
  geom_line()+
  geom_abline(aes(slope=1, intercept=0), linetype="dashed")+
  scale_y_continuous(breaks = seq(0, 1, .1))+
  scale_x_continuous(breaks = seq(0, 1, .1))
```
Overweight for larger pfrac

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model2b.R'))
sim_trial_list[['model2b']] = sim_trial
```

## Check sim task

Can we get 0 logit slopes for probFractalDraw < .5 trials for the QV difference with an assymmetric prob weighting curve as above?

```{r}
m2b_1 = sim_task(sub_data, model_name = "model2b", d=0.04, sigma = 0.01, delta = 3, gamma = 3)
sim_sanity_checks(m2b_1, yrange_lim = 50)
```

Can we reduce timeouts with a barrier decay? Yes but not entirely.

```{r}
m2b_2 = sim_task(sub_data, model_name = "model2b", d=0.03, sigma = 0.01, delta = 2, gamma = 2, barrierDecay = .007)
sim_sanity_checks(m2b_2, yrange_lim = 50)
```
Why are the logit values so high?

In the simulations choice depends only on these value differences. The model fits too well, there is very low residual deviance. Here's the true data logit:

```{r}
tmp = sub_data %>%
  filter(probFractalDraw == 1) %>%
  mutate(QVDiff = scale(QVLeft - QVRight),
         EVDiff = scale(EVLeft - EVRight))

summary(glm(choiceLeft ~ EVDiff + QVDiff, data = tmp,family=binomial(link="logit")))
```

And the logit for the simulation

```{r}
tmp = m2_2 %>%
  filter(probFractalDraw == 1) %>%
  mutate(QVDiff = scale(QVLeft - QVRight),
         EVDiff = scale(EVLeft - EVRight),
         choiceLeft = ifelse(choice == "left", 1, 0))

summary(glm(choiceLeft ~ EVDiff + QVDiff, data = tmp,family=binomial(link="logit")))
```

- Can we reduce the logit slopes by increasing epsilon? (SD of distribution the mean of drift is sampled from) Yes.

But does it also destroy the RT inverse U? Do the average RTs become more similar to each other for all intermediate probFractalDraw levels?

```{r}
m2b_3 = sim_task(sub_data, model_name = "model2b", d=0.02, sigma = 0.007, delta = 3, gamma = 3, barrierDecay = 0.004, epsilon = 0.03, nonDecisionTime = 0)
sim_sanity_checks(m2b_3)
```

- What do the trials on the slow end of the bimodal distribution look like? Are they for particularly hard trials? Yes.

Should we add something to an effect of "if options are too close to each other choose..." randomly? the first one? 

```{r}
m2b_3 %>%
  mutate(absQVDiff= abs(QVLeft - QVRight),
         absEVDiff = abs(EVLeft - EVRight),
         slowTrial = factor(ifelse(reactionTime > 3, 1, 0))) %>%
  select(absQVDiff, absEVDiff, slowTrial) %>%
  gather(key, value, -slowTrial) %>%
  ggplot(aes(value, fill=slowTrial))+
  # geom_histogram(position="identity", alpha = .5, bins=30)+
  geom_density(alpha=.5, color=NA)+
  theme(legend.position = "bottom")+
  labs(x="")+
  facet_wrap(~key)
```


# Model 3: Model 2 + relative preference weighting

- Early integration for pFractalDraw == 1 only
- Relative preference weighted value difference for all other conditions

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model3.R'))
sim_trial_list[['model3']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
m3 = sim_task(sub_data, model_name = "model3", d=0.08, sigma = 0.01)
sim_sanity_checks(m3)
```

```{r eval=FALSE, echo=FALSE}
m3 = sim_task(sub_data, model_name = "model3", d=0.06, sigma = 0.008)
sim_sanity_checks(m3)
```

# Model 4a: 3 integrators

- 3 integrators **all with their own drift and noise rates**
- Arbitrator integrator starts biased towards lotteries
- If pFractalDraw == 1 fractal integrator starts biased towards the better fractal
- Attribute relevance (pFractalDraw) affects attribute integrators directly, not the arbitrator
- Arbitrator integrator depends on the difference in absolute attribute integrator RDVs

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model4a.R'))
sim_trial_list[['model4a']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
m4a = sim_task(sub_data, model_name = "model4a", dLott=0.03, dFrac=0.04, dArb=0.04, sigmaLott = 0.03, sigmaFrac = 0.03, sigmaArb = 0.03)
sim_sanity_checks(m4a)
```

```{r eval=FALSE, echo=FALSE}
m4a = sim_task(sub_data, model_name = "model4a", dLott=0.03, dFrac=0.04, dArb=0.04, sigmaLott = 0.03, sigmaFrac = 0.03, sigmaArb = 0.01, lotteryBias= 1)
sim_sanity_checks(m4a)
```

```{r}
m4a_trial = sim_trial_list[['model4a']](dArb = .04, dLott=0.02, dFrac=0.03, sigmaArb = .01, sigmaLott = .03, sigmaFrac = .03, barrierDecay = 0, EVLeft = .7, EVRight = 0.5, QVLeft = 0, QVRight = 0, probFractalDraw = 0.5, debug=TRUE, nonDecisionTime = 0)
m4a_trial$out
```

```{r}
m4a_trial$debug_df %>%
  select(-arbitrator_mu_mean) %>%
  gather(key, value, -time, -barrier) %>%
  ggplot()+
  geom_line(aes(time, value))+
  geom_line(aes(time, barrier), color="red")+
  geom_line(aes(time, -barrier), color="green")+
  geom_hline(aes(yintercept = 0), linetype="dashed")+
  facet_grid(key ~.)+
  theme_bw()
```

# Model 5a: 3 integrators

- 3 integrators **all with their own drift and noise rates**
- Arbitrator integrator starts biased towards lotteries
- If pFractalDraw == 1 fractal integrator (not arbitrator) starts biased towards the better fractal
- Attribute relevant (pFractalDraw) does not affects attribute integrators directly
- Arbitrator integrator depends on the difference in absolute attribute integrator RDVs weighted by the attribute relevance

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model5a.R'))
sim_trial_list[['model5a']] = sim_trial
```

Example visualization of integration

```{r echo=FALSE, eval=FALSE}
m5a_trial = sim_trial_list[['model5a']](dArb = .04, dLott=0.03, dFrac=0.02, sigmaArb = .01, sigmaLott = .03, sigmaFrac = .03, barrierDecay = 0, EVLeft = .7, EVRight = 0.5, QVLeft = 0, QVRight = 0, probFractalDraw = 0, debug=TRUE, nonDecisionTime = 0)
m5a$out
```

```{r}
m5a_trial$debug_df %>%
  select(-arbitrator_mu_mean) %>%
  gather(key, value, -time, -barrier) %>%
  ggplot()+
  geom_line(aes(time, value))+
  geom_line(aes(time, barrier), color="red")+
  geom_line(aes(time, -barrier), color="green")+
  geom_hline(aes(yintercept = 0), linetype="dashed")+
  facet_grid(key ~.)+
  theme_bw()
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
m5a = sim_task(sub_data, model_name = "model5a", dLott=0.02, dFrac=0.045, dArb=0.04, sigmaLott = 0.03, sigmaFrac = 0.03, sigmaArb = 0.01)
sim_sanity_checks(tmp)
```

```{r eval=FALSE, echo=FALSE}
m5a = sim_task(sub_data, model_name = "model5a", dLott=0.035, dFrac=0.02, dArb=0.04, sigmaLott = 0.03, sigmaFrac = 0.03, sigmaArb = 0.01)
sim_sanity_checks(tmp)
```


```{r}
m5a %>%
  select(EVLeft, EVRight, QVLeft, QVRight, probFractalDraw, choice, reactionTime, arbitrator) %>%
  mutate(data_type = "sim") %>%
  rbind(sub_data %>%
          mutate(choice = ifelse(choiceLeft == 1, "left", "right"),
                 data_type = "true",
                 arbitrator= "true") %>%
          select(-subnum, -choiceLeft)) %>%
  mutate(probFractalDraw = as.factor(probFractalDraw)) %>%
  ggplot(aes(reactionTime, fill=as.factor(arbitrator))) +
  geom_histogram(position="identity", bins=30, alpha=.5) +
  labs(title="RT long tail?", fill="")+
  facet_wrap(~probFractalDraw)+
  theme(legend.position = "bottom")
```

# Model 6a: 3 integrators + early integration

- 3 integrators **all with their own drift and noise rates**
- Arbitrator integrator starts from lottery bias
- If pFractalDraw == 1 fractal and arbitrator integrator starts early. Arbitrator moves only towards fractal.
- Attribute relevance (pFractalDraw) does not affect attribute integrators directly
- Arbitrator integrator depends on the difference in absolute attribute integrator RDVs weighted by attribute relevance

- Where should nondecision time come into play?

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model6a.R'))
sim_trial_list[['model6a']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
m6a = sim_task(sub_data, model_name = "model6a", dLott=0.01, dFrac=0.045, dArb=0.05, sigmaLott = 0.03, sigmaFrac = 0.03, sigmaArb = 0.01, lotteryBias = .25)
sim_sanity_checks(m6a)
```

# Model 7a: Switching between integrators

- 3 integrators **all with their own drift and noise rates**
- Arbitrator integrator starts from lottery bias unless pFractalDraw == 1. Then it starts from 0.
- If pFractalDraw == 1 fractal and arbitrator integrator starts early. Arbitrator moves only towards fractal.
- Attribute relevance (pFractalDraw) does not affect attribute integrators directly
- Arbitrator integrator depends on the difference in absolute attribute integrator RDVs weighted by attribute relevance
- When stimulus is presented arbitrator moves only based on lotteryRDV for a short period

```{r}
source(paste0(helpers_path, 'ddmSims/ddm_model7a.R'))
sim_trial_list[['model7a']] = sim_trial
```

## Check sim task

```{r eval=FALSE, echo=FALSE}
m7a = sim_task(sub_data, model_name = "model7a", dLott=0.01, dFrac=0.06, dArb=0.06, sigmaLott = 0.03, sigmaFrac = 0.03, sigmaArb = 0.01, lotteryBias = .1)
sim_sanity_checks(m7a)
```

```{r}
m7a %>%
  select(EVLeft, EVRight, QVLeft, QVRight, probFractalDraw, choice, reactionTime, arbitrator) %>%
  mutate(data_type = "sim") %>%
  rbind(sub_data %>%
          mutate(choice = ifelse(choiceLeft == 1, "left", "right"),
                 data_type = "true",
                 arbitrator= "true") %>%
          select(-subnum, -choiceLeft)) %>%
  mutate(probFractalDraw = as.factor(probFractalDraw)) %>%
  ggplot(aes(reactionTime, fill=as.factor(arbitrator))) +
  geom_histogram(position="identity", bins=30, alpha=.5) +
  labs(title="RT long tail?", fill="")+
  facet_wrap(~probFractalDraw)+
  theme(legend.position = "bottom")
```

# Trade-offs across models

- Is the relationship between pars that optim rt vs choice the same across models?

No. There can be a trade-off between the parameters depending on what you optimize for but it's not in the same direction for all models.

```{r}
all_opt_outs = list(m1_opt_out, m2_opt_out, m3_opt_out, m4_opt_out, m5_opt_out)
opt_outs_df = data.frame()
for (i in 1:length(all_opt_outs)){
  opt_outs_df = rbind.all.columns(opt_outs_df,
                                  all_opt_outs[[i]]$opt_rt_pars %>%
                                    mutate(model_name = paste0("model", i),
                                           opt_for = "opt_rt") %>%
                                    rbind(all_opt_outs[[i]]$opt_choice_pars %>%
                                            mutate(model_name = paste0("model", i),
                                                   opt_for = "opt_choice")) %>%
                                    rbind(all_opt_outs[[i]]$opt_avg_pars %>%
                                            mutate(model_name = paste0("model", i),
                                                   opt_for = "opt_avg")))
}

opt_outs_df %>%
  select(-barrier_decay, -rt_sumsq, -choice_sumsq, -avg_sumsq) %>%
  gather(par, value, -model_name, -opt_for) %>%
  ggplot(aes(model_name, value, color=opt_for))+
  geom_point(size=4, alpha=.5)+
  facet_wrap(~par)+
  labs(x="", y="", color="")+
  theme(legend.position = "bottom")
```
```{r}
opt_outs_df
```

# Questions

- Why can I find a combination of parameters to match cases pFractalDraw > .5 but the same combination is too fast for other conditions?
- Why is the slowest condition pFractalDraw == .6 for simulations but pFractalDraw == .5 in true data?
- Change grid search optimization for RT to KL divergence?
- Incorporating EV and QV computation instead of using them as input
