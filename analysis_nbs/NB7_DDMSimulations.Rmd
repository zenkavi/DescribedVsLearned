---
title: "Experience vs. description based decision-making project: Adding arbitration to behavioral modeling"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

# Setup

Set up environment and load in data

```{r include=FALSE}
library(tidyverse)
library(gridExtra)
library(brms)
library(here)
library(broom)
cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# theme_set(theme_bw())
theme_set(theme_classic())
sem <- function(x) {sd(x, na.rm=T) / sqrt(length(x))}
helpers_path = here('helpers/')

set.seed(385723)
```

Adding in parameters from the two systems model for all subjects (i.e. not choosing the best fitting one per subject)

```{r}
source(paste0(helpers_path,'fit_twoValSystemsWithRL_hierarchical.R'))
source(paste0(helpers_path,'add_inferred_pars.R'))
clean_beh_data = add_inferred_pars(clean_beh_data, par_ests, model_name="original")
source(paste0(helpers_path,'sim_task.R'))
source(paste0(helpers_path,'sim_sanity_checks.R'))
```

# True data

### Motivation for competition

```{r}
clean_beh_data %>%
  mutate(wAbsLeftEVAdv = (1-probFractalDraw)*abs(leftEVAdv),
         wAbsLeftQVAdv = (probFractalDraw)*abs(leftQVAdv),
         EVAdvMinQVAdv = abs(wAbsLeftEVAdv - wAbsLeftQVAdv),
         probFractalDraw = as.factor(probFractalDraw)) %>%
  group_by(probFractalDraw) %>%
  summarise(meanEVAdvMinQVAdv = mean(EVAdvMinQVAdv),
            semEVAdvMinQVAdv = sem(EVAdvMinQVAdv)) %>%
  ggplot(aes(probFractalDraw, meanEVAdvMinQVAdv))+
  geom_point()+
  geom_errorbar(aes(ymin = meanEVAdvMinQVAdv - semEVAdvMinQVAdv, ymax = meanEVAdvMinQVAdv + semEVAdvMinQVAdv), width=.2)
```

```{r}
clean_beh_data %>%
  mutate(wAbsLeftEVAdv = (1-probFractalDraw)*abs(leftEVAdv),
         wAbsLeftQVAdv = (probFractalDraw)*abs(leftQVAdv),
         QVRelPref = wAbsLeftQVAdv/(wAbsLeftEVAdv +wAbsLeftQVAdv+1e-6),
         probFractalDraw = as.factor(probFractalDraw)) %>%
  group_by(probFractalDraw) %>%
  summarise(meanQVRelPref = mean(QVRelPref),
            semQVRelPref = sem(QVRelPref)) %>%
  ggplot(aes(probFractalDraw, meanQVRelPref))+
  geom_point()+
  geom_errorbar(aes(ymin = meanQVRelPref - semQVRelPref, ymax = meanQVRelPref + semQVRelPref), width=.2)
```

Filter data for a few subjects with a range of learning rates (i.e. variance in QValue differences) to simulate RTs using DDM. Rename columns to work with task simulation function. 

```{r}
sub_data = clean_beh_data %>%
  filter(subnum  %in% c("01", "03", "05","07", "09", "11", "13", "15", "17", "19")) %>%
  select(leftQValue, rightQValue, leftLotteryEV, rightLotteryEV, probFractalDraw, reactionTime, choiceLeft, subnum) %>%
  rename(EVLeft = leftLotteryEV, EVRight = rightLotteryEV, QVLeft = leftQValue, QVRight = rightQValue)
```

## Sanity checks in the sampled data

```{r}
sim_sanity_checks(sub_data %>%
                    select(-subnum) %>%
                    mutate(choice = ifelse(choiceLeft == 1, "left", "right")), 
                  compare_rts = FALSE)
```

# Model 1: 

Integrate both starting at stim presentation

DDM that can take our task specific arguments as input

```{r}
sim_trial = function(d, sigma,  barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=1000, epsilon = 0.0002, ...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a (1000 iterations * 10 ms (per iteration) / 1000 convert back to sec =) 10sec timeout maximum
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  
  valueLeft = probFractalDraw*QVLeft + (1-probFractalDraw)*(EVLeft)
  valueRight = probFractalDraw*QVRight + (1-probFractalDraw)*(EVRight)
  valDiff_mu_mean = d*(valueLeft - valueRight)
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier | RDV <= -barrier){
      RT = (time * timeStep)/1000 #convert back to secs
      if (RDV >= barrier){
        choice = "left"
      } else if (RDV <= -barrier){
        choice = "right"
      }
      break
    } 
    
    # nonDecisionTime/timeStep gives how many sampling iterations the nonDecisionTime corresponds to
    nonDecIters = nonDecisionTime / timeStep
    # If elapsed time is less than the number of sampling iterations required for the nonDecisionTime set evidence sampling distribution mean to 0 so any move from starting point would only be noise
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      # If the nonDecisionTime has passed set the mean of the distribution the decision variable will be sampled from to a value proportional to the value difference and the drift rate 
      mu_mean = valDiff_mu_mean
    }
    
    # Sample the change in RDV from the distribution with mean proportional to the value difference
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT)
  return(out)
}
```

```{r}
sim_data_m1_1 = sim_task(stimuli = sub_data, d = .06, sigma = .06)
```

```{r}
sim_sanity_checks(sim_data_m1_1)
```

# Model 2: 

Begin integration about Q values earlier if that is the only relevant option. Otherwise integrate

```{r}
sim_trial = function(d, sigma, barrierDecay, barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=400, epsilon = 0.0002, stimDelay = 2000, evCompTime = 300, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  decPreStim = 0
  timeOut = 0
  
  leftFractalAdv = NA
  leftLotteryAdv = NA
  relPrefLottery = NA
  relPrefFractal = NA
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  # Stimulus screen comes on 2 secs after the presentation of probFractalDraw
  stimDelayIters = stimDelay / timeStep
  nonDecIters = nonDecisionTime / timeStep
  evCompIters = evCompTime / timeStep
  
  # Integration starts before stim presentation (though meaningful move from 0 happens only for pFrac = 1 trials) but decision can only be indicated after stim. Since total iterations depend on maxIter the addition of iterations before stim presentation controls for the desired max time out for the trial. In the arguments to the function it is specified as the maximum time out duration after stim presentation
  maxIter = maxIter + stimDelayIters
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  # Barrier decay starts after stim presentation. Not during any possible sampling before that
  for(t in seq(stimDelayIters, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * (t-stimDelayIters))
  }
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier[time] | RDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      # Debugging
      if(debug){
        print(paste0("pre subtraction RT = ", RT))
      }
      
      #subtract stimDelay
      RT = RT - (stimDelay/1000) 
      
      # If decision is reached before the stim screen sample rt from log normal distribution similar to choice RT 
      if (RT < 0){
        if(debug){
          print("RDV crossed barrier before stimDelay")
        }
        decPreStim = 1
        RT=rlnorm(1, mean = -.25, sd = 0.5)
      }
      
      if (RDV >= barrier[time]){
        choice = "left"
      } else if (RDV <= -barrier[time]){
        choice = "right"
      }
      break
    } 
    
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      if (time < stimDelayIters){
        # Integration after fractal prob presentation but before stim presentation happens ONLY for the probfractaldraw == 1 trials
        if (probFractalDraw == 1){
          mu_mean = d*(QVLeft - QVRight)
        } else {
          # No integration after NDT and before stim presentation for any other trial type
          mu_mean = 0
        }
      } else{
        # Time for EV computation. Should create lottery bias
        if (time < (stimDelayIters + evCompIters)){
          mu_mean = d * (1-probFractalDraw) * (EVLeft - EVRight)
        } else {
          # Competition?
          # Gathering evidence based on lotteries vs fractals
          leftFractalAdv =  probFractalDraw* (QVLeft - QVRight)
          leftLotteryAdv = (1-probFractalDraw) * (EVLeft - EVRight)
          relPrefLottery = abs(leftLotteryAdv)/(abs(leftFractalAdv)+1e-6)
          relPrefFractal = abs(leftFractalAdv)/(abs(leftLotteryAdv)+1e-6)
          mu_mean = d * (relPrefFractal * leftFractalAdv + relPrefLottery * leftLotteryAdv)
          
          # How to get the inverse U?
        }
        
        
      }
    }
    
    # Sample the change in RDV from the distribution.
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    if (debug){
      print(paste0("time = ", time, " mu_mean = ", mu_mean, " mu = ", round(mu, 3), " RDV = ", round(RDV, 3), " barrier = ", round(barrier[time], 3)))
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    if (RDV >= 0){
      choice = "left"
    } else if (RDV <= 0){
      choice = "right"
    }
    if(debug){
      print("Max iterations reached.")
    }
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, decPreStim = decPreStim, leftFractalAdv = leftFractalAdv, leftLotteryAdv = leftLotteryAdv,  relPrefFractal = relPrefFractal, relPrefLottery = relPrefLottery, d = d, sigma = sigma, barrierDecay = barrierDecay)
  return(out)
}
```

```{r}
sim_trial(d = .002, sigma = .05, barrierDecay = 0.005, EVLeft = 0.7, EVRight = .5, QVLeft = 0.3, QVRight = 0.3, probFractalDraw = 0, debug=TRUE)
```

```{r}
sim_data_m2_1 = sim_task(stimuli=sub_data, d = .004, sigma = .04, barrierDecay = 0.005)
```

```{r}
sim_sanity_checks(sim_data_m2_1)
```
```{r}
sim_data_m2_1 %>% 
  filter(decPreStim == 1)
# filter(probFractalDraw == 0)
```


```{r}
sim_data_m2_2 = sim_task(stimuli=sub_data, d = .001, sigma = .04, barrierDecay = 0)
```

```{r}
sim_sanity_checks(sim_data_m2_2)
```

What is going on with the trials that hit decision before stimuli are presented but are not pfrac = 1? There should be no integration for these before the stimuli are presented. Seems to go down quickly with reducing sigma, though that messes up other things as well


```{r}
sim_data_m2_2 %>% 
  filter(decPreStim == 1)
```

# Model 3:

```{r}
sim_trial = function(d, sigma, barrierDecay, barrier=1, nonDecisionTime=0, bias=0, timeStep=10, maxIter=400, epsilon = 0.0002, stimDelay = 2000, evCompTime = 300, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  RDV = bias
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  decPreStim = 0
  timeOut = 0
  
  leftFractalAdv = NA
  leftLotteryAdv = NA
  relPrefFractal = NA
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  # Stimulus screen comes on 2 secs after the presentation of probFractalDraw
  stimDelayIters = stimDelay / timeStep
  nonDecIters = nonDecisionTime / timeStep
  evCompIters = evCompTime / timeStep
  
  # Integration starts before stim presentation (though meaningful move from 0 happens only for pFrac = 1 trials) but decision can only be indicated after stim. Since total iterations depend on maxIter the addition of iterations before stim presentation controls for the desired max time out for the trial. In the arguments to the function it is specified as the maximum time out duration after stim presentation
  maxIter = maxIter + stimDelayIters
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  # Barrier decay starts after stim presentation. Not during any possible sampling before that
  for(t in seq(stimDelayIters, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * (t-stimDelayIters))
  }
  
  while (time<maxIter){
    
    # If the RDV hit one of the barriers, the trial is over.
    if (RDV >= barrier[time] | RDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      # Debugging
      if(debug){
        print(paste0("pre subtraction RT = ", RT))
      }
      
      #subtract stimDelay
      RT = RT - (stimDelay/1000) 
      
      # If decision is reached before the stim screen sample rt from log normal distribution similar to choice RT 
      if (RT < 0){
        if(debug){
          print("RDV crossed barrier before stimDelay")
        }
        decPreStim = 1
        RT=rlnorm(1, mean = -.25, sd = 0.5)
      }
      
      if (RDV >= barrier[time]){
        choice = "left"
      } else if (RDV <= -barrier[time]){
        choice = "right"
      }
      break
    } 
    
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      if (time < stimDelayIters){
        # Integration after fractal prob presentation but before stim presentation happens ONLY for the probfractaldraw == 1 trials
        if (probFractalDraw == 1){
          mu_mean = d*(QVLeft - QVRight)
        } else {
          # No integration after NDT and before stim presentation for any other trial type
          mu_mean = 0
        }
      } else{
        
        # Time for EV computation. Should create lottery bias
        if (time < (stimDelayIters + evCompIters)){
          mu_mean = d * (1-probFractalDraw) * (EVLeft - EVRight)
        } else {
          # Competition?
          # Gathering evidence based on lotteries vs fractals' relative strength of preference
          leftFractalAdv =  probFractalDraw* (QVLeft - QVRight)
          leftLotteryAdv = (1-probFractalDraw) * (EVLeft - EVRight)
          relPrefFractal = abs(leftFractalAdv)/(abs(leftLotteryAdv)+abs(leftFractalAdv)+1e-6)
          mu_mean = d * (relPrefFractal * leftFractalAdv + (1-relPrefFractal) * leftLotteryAdv)
        }
      }
    }
    
    # Sample the change in RDV from the distribution.
    mu = rnorm(1, mu_mean, epsilon)
    RDV = RDV + rnorm(1, mu, sigma)
    
    if (debug){
      print(paste0("time = ", time, " mu_mean = ", mu_mean, " mu = ", round(mu, 3), " RDV = ", round(RDV, 3), " barrier = ", round(barrier[time], 3)))
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    if (RDV >= 0){
      choice = "left"
    } else if (RDV <= 0){
      choice = "right"
    }
    if(debug){
      print("Max iterations reached.")
    }
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, decPreStim = decPreStim, leftFractalAdv = leftFractalAdv, leftLotteryAdv = leftLotteryAdv,  relPrefFractal = relPrefFractal, d = d, sigma = sigma, barrierDecay = barrierDecay, barrier = barrier[time], RDV = RDV)
  return(out)
}
```

```{r}
sim_trial(d = .008, sigma = .01, barrierDecay = 0, EVLeft = 0.7, EVRight = .1, QVLeft = 0.7, QVRight = 0.1, probFractalDraw = .6, debug=TRUE)
```

```{r}
sim_data_m3_1 = sim_task(stimuli=sub_data, d = .006, sigma = .02, barrierDecay = 0.005)
```

```{r}
sim_sanity_checks(sim_data_m3_1)
```

```{r}
sim_data_m3_1 %>% 
  filter(decPreStim == 1)
```

```{r}
sim_data_m3_2 = sim_task(stimuli=sub_data, d = .020, sigma = .03, barrierDecay = 0.005)
```

```{r}
sim_sanity_checks(sim_data_m3_2)
```

# Model 4:

```{r}
sim_trial = function(d, sigma, barrierDecay, barrier=1, nonDecisionTime=0, lotteryBias=0.1, fractalBias = 0, timeStep=10, maxIter=400, epsilon = 0.002, debug=FALSE,...){
  
  # d : drift rate
  # sigma: sd of the normal distribution 
  # timeStep: in ms
  # nonDecisionTime: in ms
  # maxIter: num max samples. if a barrier isn't hit by this sampling of evidence no decision is made. If time step is 10ms and maxIter is 1000 this would be a 10sec timeout maximum
  
  lotteryRDV = lotteryBias
  fractalRDV = fractalBias
  arbitratorRDV = 0
  time = 1
  elapsedNDT = 0
  choice = 0
  RT = NA
  
  timeOut = 0
  
  arbitrator_mu_mean = NA
  if(debug){
    debug_df = data.frame()
  }
  
  kwargs = list(...)
  EVLeft=kwargs$EVLeft
  EVRight=kwargs$EVRight
  QVLeft=kwargs$QVLeft
  QVRight=kwargs$QVRight
  probFractalDraw=kwargs$probFractalDraw
  if(probFractalDraw == 1){
    fractalRDV = QVLeft - QVRight
  }
  
  nonDecIters = nonDecisionTime / timeStep
  
  initialBarrier = barrier
  barrier = rep(initialBarrier, maxIter)
  
  # The values of the barriers can change over time
  for(t in seq(1, maxIter, 1)){
    barrier[t] = initialBarrier / (1 + barrierDecay * t)
  }
  
  lottery_mu_mean = d * (1-probFractalDraw) * (EVLeft - EVRight)
  fractal_mu_mean = d * probFractalDraw * (QVLeft - QVRight)
  
  while (time<maxIter){
    
    # If the arbitrator RDV hits one of the barriers make decision
    if (arbitratorRDV >= barrier[time] | arbitratorRDV <= -barrier[time]){
      
      # Convert ms back to secs
      RT = (time * timeStep)/1000 
      
      if (arbitratorRDV >= barrier[time]){
        arbitrator = "EV"
        choice = ifelse(lotteryRDV > 0, "left", "right")
      } else if (arbitratorRDV <= -barrier[time]){
        arbitrator = "QV"
        choice = ifelse(fractalRDV > 0, "left", "right")
      }
      break
    } 
    
    # Otherwise continue sampling evidence
    if (elapsedNDT < nonDecIters){
      mu_mean = 0
      elapsedNDT = elapsedNDT + 1
    } else{
      
      # Three integrators
      
      # Lottery integrator
      lottery_mu = rnorm(1, lottery_mu_mean, epsilon)
      lotteryRDV = lotteryRDV + rnorm(1, lottery_mu, sigma)
      
      # Fractal integrator
      fractal_mu = rnorm(1, fractal_mu_mean, epsilon)
      fractalRDV = fractalRDV + rnorm(1, fractal_mu, sigma)
      
      # Arbitrator 
      # If abs(lotteryRDV) > abs(fractalRDV) stronger relative preference for a side based on lotteries
      arbitrator_mu_mean = d * (abs(lotteryRDV) - abs(fractalRDV))
      arbitrator_mu = rnorm(1, arbitrator_mu_mean, epsilon)
      arbitratorRDV = arbitratorRDV + rnorm(1, arbitrator_mu, sigma)
    }
    
    if (debug){
      debug_row = data.frame(time = time, arbitrator_mu_mean = round(arbitrator_mu_mean, 3), arbitratorRDV = round(arbitratorRDV, 3), barrier = round(barrier[time], 3), lotteryRDV = round(lotteryRDV, 3), fractalRDV = round(fractalRDV, 3))
      debug_df = rbind(debug_df, debug_row)
    }
    
    # Increment sampling iteration
    time = time + 1
  }
  
  #If a choice hasn't been made by the time limit
  if(is.na(RT)){
    # Choose whatever you have most evidence for
    arbitrator = ifelse(arbitratorRDV >= 0 , "EV", "QV")
    if(arbitrator == "EV"){
      choice = ifelse(lotteryRDV > 0, "left", "right")
    } else if (arbitrator == "QV"){
      choice = ifelse(fractalRDV > 0, "left", "right")
    }
   
    timeOut = 1
    RT=rlnorm(1, mean = 1.25, sd = 0.1)
  }
  
  #Organize output 
  out = data.frame(EVLeft = EVLeft, EVRight = EVRight, QVLeft = QVLeft, QVRight = QVRight, probFractalDraw = probFractalDraw, choice=choice, reactionTime = RT, timeOut = timeOut, arbitrator = arbitrator)
  
  if(debug){
    out = list(out=out, debug_df=debug_df[-1,])
  }
  
  return(out)
}
```

```{r}
tmp = sim_trial(d = .01, sigma = .01, barrierDecay = 0.005, EVLeft = 1, EVRight = 0, QVLeft = 0.3, QVRight = 0.7, probFractalDraw = 1, debug=TRUE, nonDecisionTime = 0)

tmp$debug_df %>%
  select(-arbitrator_mu_mean) %>%
  gather(key, value, -time, -barrier) %>%
  ggplot()+
  geom_line(aes(time, value))+
  geom_line(aes(time, barrier), color="red")+
  geom_line(aes(time, -barrier), color="green")+
  geom_hline(aes(yintercept = 0), linetype="dashed")+
  facet_grid(key ~.)
```

```{r}
tmp
```



```{r}
sim_data_m4_1 = sim_task(stimuli=sub_data, d = .033, sigma = .03, barrierDecay = 0.007)
```

```{r}
sim_sanity_checks(sim_data_m4_1)
```
