model {

# Define parameters.
alpha ~ dnorm(0,0.001)
beta1 ~ dnorm(0,0.001)
beta2 ~ dnorm(0,0.001)
beta3 ~ dnorm(0,0.001)
beta4 ~ dnorm(0,0.001)
lambda ~ dunif(0,1)


# Calculate Q values.
qleft[1] <- 0
qright[1] <- 0
for (i in 2:N) {
    qleft[i] <- ifelse(choiceleft[i] == 1,
        qleft[i-1] + (lambda * (rewardleft[i-1] - qleft[i-1])),
        qleft[i-1])

    qright[i] <- ifelse(choiceleft[i] == 0,
        qright[i-1] + (lambda * (rewardright[i-1] - qright[i-1])),
        qright[i-1])
}


# Create variables of interest.
for (i in 1:N) {
    rellot[i] <- ((problottery[i] * valuelottery[i]) - 0.5)
    relq[i] <- (qleft[i] - qright[i])
    wrellot[i] <- (1 - probfractaldraw[i]) * rellot[i]
    wrelq[i] <- probfractaldraw[i] * relq[i]
}

for (i in 1:N) {
    conflict[i] <- ifelse(rellot[i] * relq[i] < 0, 1, 0)
    agree[i] <- ifelse(rellot[i] * relq[i] > 0, 1, 0)
}

for (i in 1:N) {
    cwrellot[i] <- conflict[i] * wrellot[i]
    cwrelq[i] <- conflict[i] * wrelq[i]
    awrellot[i] <- agree[i] * wrellot[i]
    awrelq[i] <- agree[i] * wrelq[i]
}


# Model data.
for (i in 1:N) {
    theta[i] <- 1 / (1 + exp(-(alpha + (beta1 * cwrellot[i]) +
        (beta2 * awrellot[i]) + (beta3 * cwrelq[i]) +
        (beta4 * awrelq[i]))))   

    choice[i] ~ dbin(theta[i],1)
}
}